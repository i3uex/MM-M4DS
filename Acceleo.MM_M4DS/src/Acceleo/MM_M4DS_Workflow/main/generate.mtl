[comment encoding = UTF-8 /]
[**
 * The documentation of the module generate.
 */]
[module generate('https://www.example.org/workflow', 'https://www.example.org/contract', 'http://www.example.org/Library', 'https://www.example.org/environment', 'https://www.example.org/contractDef')]

[import Acceleo::MM_M4DS_contract::main::generate/]


[**
 * The documentation of the template generateElement.
 * @param aWorkflow
 */]

[template public generateWorkflow(aWorkflow : Workflow)]
[comment @main/]
[generateEnvironment(aWorkflow)/]
[fileFormatting(aWorkflow)/]
[generateDataProcessing(aWorkflow)/]
[generateContractsDataProcessing(aWorkflow)/]
[generateTransformationsDataProcessing(aWorkflow)/]
[/template]


[template public generateDataProcessing(aWorkflow : Workflow)]
[file ('dataProcessing_Job_'+aWorkflow.name.replaceAll('[(),-/\\s]+', '_')+'.py', false, 'UTF-8')]
import pandas as pd
import numpy as np
import functions.contract_invariants as contract_invariants
import functions.contract_pre_post as contract_pre_post
import functions.data_transformations as data_transformations
import functions.data_smells as data_smells
from helpers.enumerations import Belong, Operator, Operation, SpecialType, DataType, DerivedType, Closure, FilterType, MapOperation, MathOperator
from helpers.logger import set_logger
import pyarrow
from functions.PMML import PMMLModel

[comment generate the imports and the class/]
def generateWorkflow():
[for (ps : ProcessingStep | aWorkflow.dataprocessing)]																										[comment OPEN traverse all the DataProcessings/]
	[if (ps.incoming = null and ps.outgoing=null)]																											[comment OPEN checks if the DataProcessing is isolated (no links)/]
		[if (ps.dataProcessingDefinition.oclIsKindOf(Library::DataProcessingDefinition))]																	[comment OPEN checks if the dataPrcessingDefinition is of type DataProcessingDefinition/]
			[let dpd : Library::DataProcessingDefinition = ps.dataProcessingDefinition.oclAsType(Library::DataProcessingDefinition)]						[comment OPEN assigns the variable to be of type DataProcessingDefinition/]
				[if (dpd.oclIsKindOf(Library::Transformation))]																								[comment OPEN checks if the dataPrcessingDefinition is of type Transformation/]
					[let libT : Library::Transformation = dpd.oclAsType(Library::Transformation)]															[comment OPEN assigns the variable to be of type Transformation/]
	#-----------------New DataProcessing-----------------
						[for (dc : DataDictionary | ps.inputPort)]																							[comment OPEN read all the input datasets and store them/]
							[if (aWorkflow.environment.oclIsKindOf(Local))]																					[comment OPEN checks that the environment is local/]
	[dc.name.replaceAll('[(),-/\\s]+', '_')/]_df=[if not ps.oclAsType(DataProcessing).initial_accumulated_processing->isEmpty()]pd.read_parquet('[if (ps.oclAsType(DataProcessing).initial_accumulated_processing.eContainer(Workflow).environment.path.startsWith('.'))][ps.oclAsType(DataProcessing).initial_accumulated_processing.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][ps.oclAsType(DataProcessing).initial_accumulated_processing.eContainer(Workflow).environment.path/][/if]/data/[if (ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.trim().indexOf('.')>0)][ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.trim()/].parquet[/if]')[else]pd.read_parquet('[if (aWorkflow.environment.path.startsWith('.'))][aWorkflow.environment.path.replaceFirst('./', '/')/][else][aWorkflow.environment.path/][/if]/data/[if (dc.fileName.trim().indexOf('.')>0)][dc.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dc.fileName.trim()/].parquet[/if]')[/if]
							[/if]																															[comment CLOSE checks that the environment is local/]

						[/for]																																[comment CLOSE read all the input datasets and store them/]
						[if (ps.oclIsKindOf(DataProcessing))]																								[comment OPEN checks that the actual ProcessingStep is a DataProcessing/]
							[let d : DataProcessing = ps.oclAsType(DataProcessing)]																			[comment OPEN assigns the variable to be of type DataProcessing/]
	[generateDataSmells(d)/]
								[for (c : Contract | d.contract)]																							[comment OPEN traverse all the contracts in the DataProcessing/]
									[if (c.contract.oclIsTypeOf(ValueRange))]
										[if (c.contract.oclAsType(Contract::ValueRange).valueRangeDef.type=ContractType::PRECONDITION)]						[comment OPEN checks if the if the contract is a Precondition/]
	[generateCallContract(c.contract, d)/]
										[/if]																												[comment CLOSE checks if the if the contract is a Precondition/]
									[elseif (c.contract.oclIsTypeOf(FieldRange))]
										[if (c.contract.oclAsType(Contract::FieldRange).fieldRangeDef.type=ContractType::PRECONDITION)]						[comment OPEN checks if the if the contract is a Precondition/]
	[generateCallContract(c.contract, d)/]
										[/if]																												[comment CLOSE checks if the if the contract is a Precondition/]
									[/if]
								[/for]																														[comment CLOSE traverse all the contracts in the DataProcessing/]
	[generateCallTransformation(d, d)/]
								[for (c : Contract | d.contract)]																							[comment OPEN traverse all the contracts in the DataProcessing/]
									[if (c.contract.oclIsTypeOf(ValueRange))]
										[if (c.contract.oclAsType(Contract::ValueRange).valueRangeDef.type=ContractType::POSTCONDITION)]					[comment OPEN checks if the if the contract is a Postcondition/]
	[generateCallContract(c.contract, d)/]
										[/if]																												[comment CLOSE checks if the if the contract is a Postcondition/]
									[elseif (c.contract.oclIsTypeOf(FieldRange))]
										[if (c.contract.oclAsType(Contract::FieldRange).fieldRangeDef.type=ContractType::POSTCONDITION)]					[comment OPEN checks if the if the contract is a Postcondition/]
	[generateCallContract(c.contract, d)/]
										[/if]																												[comment CLOSE checks if the if the contract is a Precondition/]
									[/if]																													[comment CLOSE checks if the if the contract is a Postcondition/]
								[/for]																														[comment CLOSE traverse all the contracts in the DataProcessing/]
								[for (c : Contract | d.contract)]																							[comment OPEN traverse all the contracts in the DataProcessing/]
									[if (c.contract.oclIsTypeOf(Condition))]
										[if (c.contract.oclAsType(Contract::Condition).conditionDef.type=ContractType::INVARIANT)]							[comment OPEN checks if the if the contract is a Invariant/]
	[generateCallContract(c.contract, d)/]
										[/if]																												[comment CLOSE checks if the if the contract is a Invariant/]
									[/if]																													[comment CLOSE checks if the if the contract is a Invariant/]
								[/for]																														[comment CLOSE traverse all the contracts in the DataProcessing/]
							[/let]																															[comment CLOSE assigns the variable to be of type DataProcessing/]
						[/if]																																[comment CLOSE checks that the actual ProcessingStep is a DataProcessing/]
						[if (ps.oclIsKindOf(PMMLModel))]																									[comment OPEN checks that the actual ProcessingStep is a PMMLModel/]
							[let pmml : PMMLModel = ps.oclAsType(PMMLModel)]																				[comment OPEN assigns the variable to be of type PMMLModel/]
	[generatePMML(pmml, ps)/]
							[/let]																															[comment CLOSE assigns the variable to be of type PMMLModel/]
						[/if]																																[comment CLOSE checks that the actual ProcessingStep is a PMMLModel/]
					[/let]																																	[comment CLOSE assigns the variable to be of type Transformation/]
				[elseif (dpd.oclIsKindOf(Library::Job))]																									[comment OPEN checks if the dataPrcessingDefinition is of type Job/]
					[let libJ : Library::Job = dpd.oclAsType(Library::Job)]																					[comment OPEN assigns the variable to be of type Job/]
	#--------------------------------------Input data dictionaries--------------------------------------
						[for (arg : Argument | ps._in)]																										[comment OPEN traverse all the input arguments/]
							[if (arg.oclIsKindOf(DataDictionary))]																							[comment OPEN checks if the argument is a DataDictionary/]
								[let dd_in : DataDictionary = arg.oclAsType(DataDictionary)]																[comment OPEN assigns the variables to be a DataDictionary/]
									[if (aWorkflow.environment.oclIsKindOf(Local))]																			[comment OPEN checks if it is a local file and a container/]
	[dd_in.dataDictionaryDefinition.boundTo.name.replaceAll('[(),-/\\s]+', '_')/]='[if (aWorkflow.environment.path.startsWith('.'))][aWorkflow.environment.path.replaceFirst('./', '/')/][else][aWorkflow.environment.path/][/if]/data/[if not ps.oclAsType(DataProcessing).initial_accumulated_processing->isEmpty()][if (ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.trim().indexOf('.')>0)][ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.trim()/].parquet[/if][else][if (dd_in.fileName.trim().indexOf('.')>0)][dd_in.fileName.replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_in.fileName.trim()/].parquet[/if][/if]'
									[/if]																													[comment CLOSE checks if it is a local file and a container or a local environmenr/]
								[/let]																														[comment CLOSE assigns the variables to be a DataDictionary/]
							[/if]																															[comment CLOSE checks if the argument is a DataDictionary/]
						[/for]																																[comment CLOSE traverse all the input arguments/]
	#--------------------------------------Output data dictionaries--------------------------------------
						[for (arg : Argument | ps.out)]																										[comment OPEN traverse all the output arguments/]
							[if (arg.oclIsKindOf(DataDictionary))]																							[comment OPEN checks if the argument is a DataDictionary/]
								[let dd_out : DataDictionary = arg.oclAsType(DataDictionary)]																[comment OPEN assigns the variables to be a DataDictionary/]
									[if (aWorkflow.environment.oclIsKindOf(Local))]																			[comment OPEN checks if it is a local file and a container/]
	[dd_out.dataDictionaryDefinition.boundTo.name.replaceAll('[(),-/\\s]+', '_')/]='[if (aWorkflow.environment.path.startsWith('.'))][aWorkflow.environment.path.replaceFirst('./', '/')/][else][aWorkflow.environment.path/][/if]/data/[if (dd_out.fileName.trim().indexOf('.')>0)][dd_out.fileName.replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_out.fileName.trim()/].parquet[/if]'
									[/if]																													[comment CLOSE checks if it is a local file and a container or a local environment/]
								[/let]																														[comment CLOSE assigns the variables to be a DataDictionary/]
							[/if]																															[comment CLOSE checks if the argument is a DataDictionary/]
						[/for]																																[comment CLOSE traverse all the output arguments/]

						[for (pstep : ProcessingStep | libJ.workflow.dataprocessing)]																		[comment OPEN traverse the dataProcessings in the workflow/]
							[if (pstep.incoming = null and pstep.outgoing=null)]																			[comment OPEN checks if the dataProcessing is isolated/]
								[if (pstep.oclIsKindOf(DataProcessing))]																					[comment OPEN checks that the original ProcessingStep is a DataProcessing/]
									[let dataP : DataProcessing = pstep.oclAsType(DataProcessing)]															[comment OPEN assigns the variables to be a DataProcessing/]
										[if (ps.oclIsKindOf(DataProcessing))]																				[comment OPEN checks that the actual ProcessingStep is a DataProcessing/]
											[let d : DataProcessing = ps.oclAsType(DataProcessing)]															[comment OPEN assigns the variables to be a DataProcessing/]
	[generateDataSmells(d)/]
												[for (c : Contract | dataP.contract)]																		[comment OPEN traverse all the contracts in the DataProcessing/]
													[if (c.contract.oclIsTypeOf(ValueRange))]
														[if (c.contract.oclAsType(Contract::ValueRange).valueRangeDef.type=ContractType::PRECONDITION)]		[comment OPEN checks if the if the contract is a Precondition/]
	[generateCallContract(c.contract, d)/]
														[/if]																								[comment CLOSE checks if the if the contract is a Precondition/]
													[elseif (c.contract.oclIsTypeOf(FieldRange))]
														[if (c.contract.oclAsType(Contract::FieldRange).fieldRangeDef.type=ContractType::PRECONDITION)]		[comment OPEN checks if the if the contract is a Precondition/]
	[generateCallContract(c.contract, d)/]
														[/if]																								[comment CLOSE checks if the if the contract is a Precondition/]
													[/if]
												[/for]																										[comment CLOSE traverse all the contracts in the DataProcessing/]
	[generateCallTransformation(dataP, d)/]
												[for (c : Contract | dataP.contract)]																		[comment OPEN traverse all the contracts in the DataProcessing/]
													[if (c.contract.oclIsTypeOf(ValueRange))]
														[if (c.contract.oclAsType(Contract::ValueRange).valueRangeDef.type=ContractType::POSTCONDITION)]	[comment OPEN checks if the if the contract is a Postcondition/]
	[generateCallContract(c.contract, d)/]
														[/if]																								[comment CLOSE checks if the if the contract is a Postcondition/]
													[elseif (c.contract.oclIsTypeOf(FieldRange))]
														[if (c.contract.oclAsType(Contract::FieldRange).fieldRangeDef.type=ContractType::POSTCONDITION)]	[comment OPEN checks if the if the contract is a Postcondition/]
	[generateCallContract(c.contract, d)/]
														[/if]																								[comment CLOSE checks if the if the contract is a Precondition/]
													[/if]																									[comment CLOSE checks if the if the contract is a Postcondition/]
												[/for]																										[comment CLOSE traverse all the contracts in the DataProcessing/]
												[for (c : Contract | dataP.contract)]																		[comment OPEN traverse all the contracts in the DataProcessing/]
													[if (c.contract.oclIsTypeOf(Condition))]
														[if (c.contract.oclAsType(Contract::Condition).conditionDef.type=ContractType::INVARIANT)]			[comment OPEN checks if the if the contract is a Invariant/]
	[generateCallContract(c.contract, d)/]
														[/if]																								[comment CLOSE checks if the if the contract is a Invariant/]
													[/if]																									[comment CLOSE checks if the if the contract is a Invariant/]
												[/for]																										[comment CLOSE traverse all the contracts in the DataProcessing/]
											[/let]																											[comment CLOSE assigns the variables to be a DataProcessing/]
										[/if]																												[comment CLOSE checks that the actual ProcessingStep is a DataProcessing/]
									[/let]																													[comment CLOSE assigns the variables to be a DataProcessing/]
								[/if]																														[comment CLOSE checks that the original ProcessingStep is a DataProcessing/]
							[/if]																															[comment CLOSE checks if the dataProcessing is isolated/]
						[/for]																																[comment CLOSE traverse the dataProcessings in the workflow/]
						[for (pstep : ProcessingStep | libJ.workflow.dataprocessing)]																		[comment OPEN traverse the dataProcessings in the workflow/]
							[if (pstep.incoming = null and pstep.outgoing<>null)]																			[comment OPEN checks if the dataProcessing is isolated/]
[callModifiedRecursiveTemplate(pstep, ps)/]
							[/if]																															[comment CLOSE checks that the dataProcessing is not isolated and is the first/]
						[/for]																																[comment CLOSE traverse the dataProcessings in the workflow/]
					[/let]																																	[comment CLOSE assigns the variable to be of type Job/]
				[/if]																																		[comment CLOSE checks if the dataPrcessingDefinition is of type Transformation or Job/]
			[/let]																																			[comment CLOSE assigns the variable to be of type DataProcessingDefinition/]
		[/if]																																				[comment CLOSE checks if the dataPrcessingDefinition is of type DataProcessingDefinition/]
	[/if]																																					[comment CLOSE checks if the DataProcessing is isolated (no links)/]
[/for]																																						[comment CLOSE traverse all the DataProcessings/]

[for (ps : ProcessingStep | aWorkflow.dataprocessing)]																										[comment OPEN traverse all the DataProcessings/]
	[if (ps.incoming = null and ps.outgoing<>null)]																											[comment OPEN checks if the DataProcessing is the first (no input link, an output link)/]
		[if (ps.dataProcessingDefinition.oclIsKindOf(Library::DataProcessingDefinition))]																	[comment OPEN checks if the dataPrcessingDefinition is of type DataProcessingDefinition/]
			[let dpd : Library::DataProcessingDefinition = ps.dataProcessingDefinition.oclAsType(Library::DataProcessingDefinition)]						[comment OPEN assigns the variable to be of type DataProcessingDefinition/]
				[if (dpd.oclIsKindOf(Library::Transformation))]																								[comment OPEN checks if the dataPrcessingDefinition is of type Transformation/]
					[let libT : Library::Transformation = dpd.oclAsType(Library::Transformation)]															[comment OPEN assigns the variable to be of type Transformation/]
[callRecursiveTemplate(ps)/]
					[/let]																																	[comment CLOSE assigns the variable to be of type Transformation/]
				[elseif (dpd.oclIsKindOf(Library::Job))]																									[comment OPEN checks if the dataPrcessingDefinition is of type Job/]
					[let libJ : Library::Job = dpd.oclAsType(Library::Job)]																					[comment OPEN assigns the variable to be of type Job/]
	#--------------------------------------Input data dictionaries--------------------------------------
						[for (arg : Argument | ps._in)]																										[comment OPEN traverse all the input arguments/]
							[if (arg.oclIsKindOf(DataDictionary))]																							[comment OPEN checks if the argument is a DataDictionary/]
								[let dd_in : DataDictionary = arg.oclAsType(DataDictionary)]																[comment OPEN assigns the variables to be a DataDictionary/]
									[if (aWorkflow.environment.oclIsKindOf(Local))]																			[comment OPEN checks if it is a local file and a container/]
	[dd_in.dataDictionaryDefinition.boundTo.name.replaceAll('[(),-/\\s]+', '_')/]='[if (aWorkflow.environment.path.startsWith('.'))][aWorkflow.environment.path.replaceFirst('./', '/')/][else][aWorkflow.environment.path/][/if]/data/[if not ps.oclAsType(DataProcessing).initial_accumulated_processing->isEmpty()][if (ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.trim().indexOf('.')>0)][ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.trim()/].parquet[/if][else][if (dd_in.fileName.trim().indexOf('.')>0)][dd_in.fileName.replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_in.fileName.trim()/].parquet[/if][/if]'
									[/if]																													[comment CLOSE checks if it is a local file and container or a local environment/]
								[/let]																														[comment CLOSE assigns the variables to be a DataDictionary/]
							[/if]																															[comment CLOSE checks if the argument is a DataDictionary/]
						[/for]																																[comment CLOSE traverse all the input arguments/]
	#--------------------------------------Output data dictionaries--------------------------------------
						[for (arg : Argument | ps.out)]																										[comment OPEN traverse all the output arguments/]
							[if (arg.oclIsKindOf(DataDictionary))]																							[comment OPEN checks if the argument is a DataDictionary/]
								[let dd_out : DataDictionary = arg.oclAsType(DataDictionary)]																[comment OPEN assigns the variables to be a DataDictionary/]
									[if (aWorkflow.environment.oclIsKindOf(Local))]																			[comment OPEN checks if it is a local file and a container/]
	[dd_out.dataDictionaryDefinition.boundTo.name.replaceAll('[(),-/\\s]+', '_')/]='[if (aWorkflow.environment.path.startsWith('.'))][aWorkflow.environment.path.replaceFirst('./', '/')/][else][aWorkflow.environment.path/][/if]/data/[if (dd_out.fileName.trim().indexOf('.')>0)][dd_out.fileName.replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_out.fileName.trim()/].parquet[/if]'
									[/if]																													[comment CLOSE checks if it is a local file and container or a local environment/]
								[/let]																														[comment CLOSE assigns the variables to be a DataDictionary/]
							[/if]																															[comment CLOSE checks if the argument is a DataDictionary/]
						[/for]																																[comment CLOSE traverse all the output arguments/]
						
						[if (ps.oclIsKindOf(DataProcessing))]																								[comment OPEN checks if the actual ProcessingStep is a DataProcessing/]
							[let d : DataProcessing = ps.oclAsType(DataProcessing)]																			[comment OPEN assigns the variable to be a DataProcessing/]
								[for (pstep : ProcessingStep | libJ.workflow.dataprocessing)]																[comment OPEN traverse the dataProcessings in the workflow/]
									[if (pstep.incoming = null and pstep.outgoing=null)]																	[comment OPEN checks if the dataProcessing is isolated/]
										[if (pstep.oclIsKindOf(DataProcessing))]																			[comment OPEN checks if the original ProcessingStep is a DataProcessing/]
											[let dataP : DataProcessing = pstep.oclAsType(DataProcessing)]													[comment OPEN assigns the variable to be a DataProcessing/]
	[generateDataSmells(d)/]
												[for (c : Contract | dataP.contract)]																		[comment OPEN traverse all the contracts in the DataProcessing/]
													[if (c.contract.oclIsTypeOf(ValueRange))]
														[if (c.contract.oclAsType(Contract::ValueRange).valueRangeDef.type=ContractType::PRECONDITION)]		[comment OPEN checks if the if the contract is a Precondition/]
	[generateCallContract(c.contract, d)/]
														[/if]																								[comment CLOSE checks if the if the contract is a Precondition/]
													[elseif (c.contract.oclIsTypeOf(FieldRange))]
														[if (c.contract.oclAsType(Contract::FieldRange).fieldRangeDef.type=ContractType::PRECONDITION)]		[comment OPEN checks if the if the contract is a Precondition/]
	[generateCallContract(c.contract, d)/]
														[/if]																								[comment CLOSE checks if the if the contract is a Precondition/]
													[/if]
												[/for]																										[comment CLOSE traverse all the contracts in the DataProcessing/]
	[generateCallTransformation(dataP, d)/]
												[for (c : Contract | dataP.contract)]																		[comment OPEN traverse all the contracts in the DataProcessing/]
													[if (c.contract.oclIsTypeOf(ValueRange))]
														[if (c.contract.oclAsType(Contract::ValueRange).valueRangeDef.type=ContractType::POSTCONDITION)]	[comment OPEN checks if the if the contract is a Postcondition/]
	[generateCallContract(c.contract, d)/]
														[/if]																								[comment CLOSE checks if the if the contract is a Postcondition/]
													[elseif (c.contract.oclIsTypeOf(FieldRange))]
														[if (c.contract.oclAsType(Contract::FieldRange).fieldRangeDef.type=ContractType::POSTCONDITION)]	[comment OPEN checks if the if the contract is a Postcondition/]
	[generateCallContract(c.contract, d)/]
														[/if]																								[comment CLOSE checks if the if the contract is a Precondition/]
													[/if]																									[comment CLOSE checks if the if the contract is a Postcondition/]
												[/for]																										[comment CLOSE traverse all the contracts in the DataProcessing/]
												[for (c : Contract | dataP.contract)]																		[comment OPEN traverse all the contracts in the DataProcessing/]
													[if (c.contract.oclIsTypeOf(Condition))]
														[if (c.contract.oclAsType(Contract::Condition).conditionDef.type=ContractType::INVARIANT)]			[comment OPEN checks if the if the contract is a Invariant/]
	[generateCallContract(c.contract, d)/]
														[/if]																								[comment CLOSE checks if the if the contract is a Invariant/]
													[/if]																									[comment CLOSE checks if the if the contract is a Invariant/]
												[/for]																										[comment CLOSE traverse all the contracts in the DataProcessing/]
											[/let]																											[comment CLOSE assigns the variable to be a DataProcessing/]
										[/if]																												[comment CLOSE checks if the actual ProcessingStep is a DataProcessing/]
									[/if]																													[comment CLOSE checks if the dataProcessing is isolated/]
								[/for]																														[comment CLOSE traverse the dataProcessings in the workflow/]
								[for (pstep : ProcessingStep | libJ.workflow.dataprocessing)]																[comment OPEN traverse the dataProcessings in the workflow/]
									[if (pstep.incoming = null and pstep.outgoing<>null)]																	[comment OPEN checks if the dataProcessing is isolated/]
[callModifiedRecursiveTemplate(pstep, ps)/]
									[/if]																													[comment CLOSE checks that the dataProcessing is not isolated and is the first/]
								[/for]																														[comment CLOSE traverse the dataProcessings in the workflow/]
							[/let]																															[comment CLOSE assigns the variable to be a DataProcessing/]
						[/if]																																[comment CLOSE checks if the actual ProcessingStep is a DataProcessing/]
						[if (ps.oclIsKindOf(PMMLModel))]																									[comment OPEN checks if the actual ProcessingStep is a PMMLModel/]
							[for (pstep : ProcessingStep | libJ.workflow.dataprocessing)]																	[comment OPEN traverse the ProcessingStep in the workflow/]
								[if (pstep.incoming = null and pstep.outgoing<>null)]																		[comment OPEN checks if the original ProcessingStep is not isolated and is the first/]
[callModifiedRecursiveTemplate(pstep, ps)/]
								[/if]																														[comment CLOSE checks if the original ProcessingStep is not isolated and is the first/]
							[/for]																															[comment CLOSE traverse the ProcessingStep in the workflow/]
						[/if]																																[comment CLOSE checks if the actual ProcessingStep is a PMMLModel/]
					[/let]																																	[comment CLOSE assigns the variable to be of type Job/]
				[/if]																																		[comment CLOSE checks if the dataPrcessingDefinition is of type Transformation or Job/]
			[/let]																																			[comment CLOSE assigns the variable to be of type DataProcessingDefinition/]
		[/if]																																				[comment CLOSE checks if the dataPrcessingDefinition is of type DataProcessingDefinition/]
	[/if]																																					[comment CLOSE checks if the DataProcessing is the first (no input link, an output link)/]
[/for]																																						[comment CLOSE traverse all the DataProcessings/]
set_logger("dataProcessing")
generateWorkflow()
[/file]
[/template]


[template public callModifiedRecursiveTemplate(pstep : ProcessingStep, ps : ProcessingStep)]		[comment]pstep, dw, dataP son el modelo grande. El que tiene todos los dataProcessing con las transformaciones y los contratos[/comment]
	#-----------------New DataProcessing-----------------
[if (pstep.incoming <> null)]																		[comment OPEN checks that it is not the first data processing/]
	[if (pstep.incoming.source.dataProcessingDefinition.name<>'split')]								[comment OPEN checks if the operation is not split/]
		[for (dd_in : DataDictionary | pstep.inputPort)]											[comment OPEN traverse all the input datasets in the ProcessingStep/]
	[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df=[if not ps.oclAsType(DataProcessing).initial_accumulated_processing->isEmpty()]pd.read_parquet([ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().name.replaceAll('[(),-/\\s]+', '_')/])[else]pd.read_parquet([dd_in.name.replaceAll('[(),-/\\s]+', '_')/])[/if]
		[/for]																						[comment CLOSE traverse all the input datasets in the ProcessingStep/]

	[else]																							[comment OPEN checks that the operation is split/]
		[for (dc : DataDictionary | pstep.inputPort)]												[comment OPEN read all the input datasets and store them/]
			[for (dc_out : DataDictionary | pstep.incoming.source.outputPort)]						[comment OPEN read the previous DataProcessing output datasets/]
				[if (dc.fileName.trim() = dc_out.fileName)]											[comment OPEN checks that both datasets are the same/]
	[dc.name.replaceAll('[(),-/\\s]+', '_')/]_df=[if not ps.oclAsType(DataProcessing).initial_accumulated_processing->isEmpty()]pd.read_parquet([ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().name.replaceAll('[(),-/\\s]+', '_')/])[else]pd.read_parquet([dc.name.replaceAll('[(),-/\\s]+', '_')/])[/if]
				[/if]																				[comment CLOSE checks that both datasets are the same/]
			[/for]																					[comment CLOSE read the previous DataProcessing output datasets/]
		[/for]																						[comment CLOSE read all the input datasets and store them/]
	[/if]																							[comment CLOSE checks whether the operation is split or not/]
[else]																								[comment OPEN checks if it is the first data processing/]
	[for (dc : DataDictionary | pstep.inputPort)]													[comment OPEN read all the input datasets and store them/]
		[if (ps.eContainer(Workflow).environment.oclIsKindOf(Local))]								[comment OPEN checks if it is a local file/]
	[dc.name.replaceAll('[(),-/\\s]+', '_')/]_df=[if not ps.oclAsType(DataProcessing).initial_accumulated_processing->isEmpty()]pd.read_parquet([ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().name.replaceAll('[(),-/\\s]+', '_')/])[else]pd.read_parquet([dc.name.replaceAll('[(),-/\\s]+', '_')/])[/if]
		[/if]																						[comment CLOSE checks if it is a local file/]

	[/for]																							[comment CLOSE read all the input datasets and store them/]
[/if]																								[comment CLOSE checks whether it is the first data processing or not/]
[if (pstep.oclIsKindOf(DataProcessing))]															[comment OPEN checks that the original ProcessingStep is a DataProcessing/]
	[let dw : DataProcessing = pstep.oclAsType(DataProcessing)]										[comment OPEN assigns the variable to be a DataProcessing/]
		[if (ps.oclIsKindOf(DataProcessing))]														[comment OPEN checks that the actual ProcessingStep is a DataProcessing/]
			[let d_or : DataProcessing = ps.oclAsType(DataProcessing)]								[comment OPEN assigns the variable to be a DataProcessing/]
	[generateDataSmells(d_or)/]
				[for (c : Contract | dw.contract)]													[comment OPEN traverse all the contracts in the DataProcessing/]
					[if (c.contract.oclIsTypeOf(ValueRange))]
						[if (c.contract.oclAsType(Contract::ValueRange).valueRangeDef.type=ContractType::PRECONDITION)]		[comment OPEN checks if the if the contract is a Precondition/]
	[generateCallContract(c.contract, d_or)/]
						[/if]																		[comment CLOSE checks if the if the contract is a Precondition/]
					[elseif (c.contract.oclIsTypeOf(FieldRange))]
						[if (c.contract.oclAsType(Contract::FieldRange).fieldRangeDef.type=ContractType::PRECONDITION)]		[comment OPEN checks if the if the contract is a Precondition/]
	[generateCallContract(c.contract, d_or)/]
						[/if]																		[comment CLOSE checks if the if the contract is a Precondition/]
					[/if]
				[/for]																				[comment CLOSE traverse all the contracts in the DataProcessing/]
	[generateCallTransformation(dw, d_or)/]	
				[for (c : Contract | dw.contract)]													[comment OPEN traverse all the contracts in the DataProcessing/]
					[if (c.contract.oclIsTypeOf(ValueRange))]
						[if (c.contract.oclAsType(Contract::ValueRange).valueRangeDef.type=ContractType::POSTCONDITION)]	[comment OPEN checks if the if the contract is a Postcondition/]
	[generateCallContract(c.contract, d_or)/]
						[/if]																		[comment CLOSE checks if the if the contract is a Postcondition/]
					[elseif (c.contract.oclIsTypeOf(FieldRange))]
						[if (c.contract.oclAsType(Contract::FieldRange).fieldRangeDef.type=ContractType::POSTCONDITION)]	[comment OPEN checks if the if the contract is a Postcondition/]
	[generateCallContract(c.contract, d_or)/]
						[/if]																		[comment CLOSE checks if the if the contract is a Precondition/]
					[/if]																			[comment CLOSE checks if the if the contract is a Postcondition/]
				[/for]																				[comment CLOSE traverse all the contracts in the DataProcessing/]
				[for (c : Contract | dw.contract)]													[comment OPEN traverse all the contracts in the DataProcessing/]
					[if (c.contract.oclIsTypeOf(Condition))]
						[if (c.contract.oclAsType(Contract::Condition).conditionDef.type=ContractType::INVARIANT)]			[comment OPEN checks if the if the contract is a Invariant/]
	[generateCallContract(c.contract, d_or)/]
						[/if]																		[comment CLOSE checks if the if the contract is a Invariant/]
					[/if]																			[comment CLOSE checks if the if the contract is a Invariant/]
				[/for]																				[comment CLOSE traverse all the contracts in the DataProcessing/]
			[/let]																					[comment CLOSE assigns the variable to be a DataProcessing/]
		[/if]																						[comment CLOSE checks that the actual ProcessingStep is a DataProcessing/]
	[/let]																							[comment CLOSE assigns the variable to be a DataProcessing/]
[elseif (pstep.oclIsKindOf(PMMLModel))]																[comment OPEN checks that the original ProcessingStep is a PMMLModel/]
	[let pmml : PMMLModel = pstep.oclAsType(PMMLModel)]												[comment OPEN assigns the variable to be a PMMLModel/]
	[generatePMML(pmml, ps)/]
	[/let]																							[comment CLOSE assigns the variable to be a PMMLModel/]
[/if]																								[comment CLOSE checks that the original ProcessingStep is a DataProcessing or a PMMLModel/]
[if (pstep.outgoing<>null)]																			[comment OPEN checks if the DataProcessing has an outgoing link (it's not the last)/]
	[let nextPstep : ProcessingStep = pstep.outgoing.target]										[comment OPEN assigns the next DataProcessing to a variable/]
[callModifiedRecursiveTemplate(nextPstep, ps)/]			[comment Recursive call to this template to generate all the DataProcessings linked to the first/]
	[/let]																							[comment OPEN assigns the next DataProcessing to a variable/]
[/if]																								[comment CLOSE checks if the DataProcessing has an outgoing link (it's not the last)/]
[/template]


[template public callRecursiveTemplate(ps : ProcessingStep)]
	#-----------------New DataProcessing-----------------
[if (ps.incoming <> null)]																										[comment OPEN checks that it is not the first data processing/]
	[if (ps.incoming.source.dataProcessingDefinition.name<>'split')]															[comment OPEN checks that the operation is not split/]
		[if (ps.eContainer(Workflow).environment.oclIsKindOf(Local))]															[comment OPEN checks if it is a local file and a container/]
			[for (dd_in : DataDictionary | ps.inputPort)]																		[comment OPEN traverse all the input datasets in the ProcessingStep/]
	[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet('[if (ps.eContainer(Workflow).environment.path.startsWith('.'))][ps.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][ps.eContainer(Workflow).environment.path/][/if]/data/[if not ps.oclAsType(DataProcessing).initial_accumulated_processing->isEmpty()][if (ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.trim().indexOf('.')>0)][ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.trim()/].parquet[/if][else][if (dd_in.fileName.trim().indexOf('.')>0)][dd_in.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_in.fileName.trim()/].parquet[/if][/if]')
			[/for]																												[comment CLOSE traverse all the input datasets in the ProcessingStep/]
		[/if]																													[comment CLOSE checks if it is a local file and a container or a local environment/]

	[else]																														[comment OPEN checks if the operation is split/]
		[for (dc : DataDictionary | ps.inputPort)]																				[comment OPEN read all the input datasets and store them/]
			[for (dc_out : DataDictionary | ps.incoming.source.outputPort)]														[comment OPEN read the previous DataProcessing output datasets/]
				[if (dc.fileName.trim() = dc_out.fileName.trim())]																[comment OPEN checks that both datasets are the same/]
					[if (ps.eContainer(Workflow).environment.oclIsKindOf(Local))]												[comment OPEN checks if it is a local file and a container/]
	[dc.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet('[if (ps.eContainer(Workflow).environment.path.startsWith('.'))][ps.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][ps.eContainer(Workflow).environment.path/][/if]/data/[if (dc_out.fileName.trim().indexOf('.')>0)][dc_out.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dc_out.fileName.trim()/].parquet[/if]')
					[/if]																										[comment CLOSE checks if it is a local file and a container or a local environment/]
				[/if]																											[comment CLOSE checks that both datasets are the same/]
			[/for]																												[comment CLOSE read the previous DataProcessing output datasets/]
		[/for]																													[comment CLOSE read all the input datasets and store them/]
	[/if]																														[comment CLOSE checks whether the operation is split or not/]
[else]																															[comment CLOSE checks that it is not the first data processing/]
	[for (dc : DataDictionary | ps.inputPort)]																					[comment OPEN read all the input datasets and store them/]
		[if (ps.eContainer(Workflow).environment.oclIsKindOf(Local))]															[comment OPEN checks if it is a local file and a container/]
	[dc.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet('[if (ps.eContainer(Workflow).environment.path.startsWith('.'))][ps.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][ps.eContainer(Workflow).environment.path/][/if]/data/[if not ps.oclAsType(DataProcessing).initial_accumulated_processing->isEmpty()][if (ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.trim().indexOf('.')>0)][ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.trim()/].parquet[/if][else][if (dc.fileName.trim().indexOf('.')>0)][dc.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dc.fileName.trim()/].parquet[/if][/if]')
		[/if]																													[comment CLOSE checks if it is a local file and a container or a local environment/]

	[/for]																														[comment CLOSE read all the input datasets and store them/]
[/if]																															[comment CLOSE checks whether it is the first data processing or not/]
[if (ps.oclIsKindOf(DataProcessing))]																							[comment OPEN checks that the ProcessingStep is a DataProcessing/]
	[let d : DataProcessing = ps.oclAsType(DataProcessing)]																		[comment OPEN assigns the variable to be a DataProcessing/]
	[generateDataSmells(d)/]
		[for (c : Contract | d.contract)]																						[comment OPEN traverse all the contracts in the DataProcessing/]
			[if (c.contract.oclIsTypeOf(ValueRange))]
				[if (c.contract.oclAsType(Contract::ValueRange).valueRangeDef.type=ContractType::PRECONDITION)]					[comment OPEN checks if the if the contract is a Precondition/]
	[generateCallContract(c.contract, d)/]
				[/if]																											[comment CLOSE checks if the if the contract is a Precondition/]
			[elseif (c.contract.oclIsTypeOf(FieldRange))]
				[if (c.contract.oclAsType(Contract::FieldRange).fieldRangeDef.type=ContractType::PRECONDITION)]					[comment OPEN checks if the if the contract is a Precondition/]
	[generateCallContract(c.contract, d)/]
				[/if]																											[comment CLOSE checks if the if the contract is a Precondition/]
			[/if]
		[/for]																													[comment CLOSE traverse all the contracts in the DataProcessing/]
	[generateCallTransformation(d, d)/]
		[for (c : Contract | d.contract)]																						[comment OPEN traverse all the contracts in the DataProcessing/]
			[if (c.contract.oclIsTypeOf(ValueRange))]
				[if (c.contract.oclAsType(Contract::ValueRange).valueRangeDef.type=ContractType::POSTCONDITION)]				[comment OPEN checks if the if the contract is a Postcondition/]
	[generateCallContract(c.contract, d)/]
				[/if]																											[comment CLOSE checks if the if the contract is a Postcondition/]
			[elseif (c.contract.oclIsTypeOf(FieldRange))]
				[if (c.contract.oclAsType(Contract::FieldRange).fieldRangeDef.type=ContractType::POSTCONDITION)]				[comment OPEN checks if the if the contract is a Postcondition/]
	[generateCallContract(c.contract, d)/]
				[/if]																											[comment CLOSE checks if the if the contract is a Precondition/]
			[/if]																												[comment CLOSE checks if the if the contract is a Postcondition/]
		[/for]																													[comment CLOSE traverse all the contracts in the DataProcessing/]
		[for (c : Contract | d.contract)]																						[comment OPEN traverse all the contracts in the DataProcessing/]
			[if (c.contract.oclIsTypeOf(Condition))]
				[if (c.contract.oclAsType(Contract::Condition).conditionDef.type=ContractType::INVARIANT)]						[comment OPEN checks if the if the contract is a Invariant/]
	[generateCallContract(c.contract, d)/]
				[/if]																											[comment CLOSE checks if the if the contract is a Invariant/]
			[/if]																												[comment CLOSE checks if the if the contract is a Invariant/]
		[/for]																													[comment CLOSE traverse all the contracts in the DataProcessing/]
	[/let]																														[comment CLOSE assigns the variable to be a DataProcessing/]
[elseif (ps.oclIsKindOf(PMMLModel))]																							[comment OPEN checks that the ProcessingStep is a PMMLModel/]
	[let pmml : PMMLModel = ps.oclAsType(PMMLModel)]																			[comment OPEN assigns the variable to be a PMMLModel/]
	[generatePMML(pmml, ps)/]
	[/let]																														[comment CLOSE assigns the variable to be a PMMLModel/]
[/if]																															[comment CLOSE checks that the ProcessingStep is a DataProcessing or a PMMLModel/]
[if (ps.outgoing<>null)]																										[comment OPEN checks if the DataProcessing has an outgoing link (it's not the last)/]
	[let nextPs : ProcessingStep = ps.outgoing.target]																			[comment OPEN assigns the next DataProcessing to a variable/]
[callRecursiveTemplate(nextPs)/]							[comment Recursive call to this template to generate all the DataProcessings linked to the first/]
	[/let]																														[comment OPEN assigns the next DataProcessing to a variable/]
[/if]																															[comment CLOSE checks if the DataProcessing has an outgoing link (it's not the last)/]
[/template]


[template public generateContractsDataProcessing(aWorkflow : Workflow)]
[file ('contracts_Job_'+aWorkflow.name.replaceAll('[(),-/\\s]+', '_')+'.py', false, 'UTF-8')]
import os

import pandas as pd
import numpy as np
import functions.contract_invariants as contract_invariants
import functions.contract_pre_post as contract_pre_post
import functions.data_smells as data_smells
from helpers.enumerations import Belong, Operator, Operation, SpecialType, DataType, DerivedType, Closure, FilterType, MapOperation, MathOperator
from helpers.logger import set_logger
import pyarrow
from functions.PMML import PMMLModel

[comment generate the imports and the class/]
def generateWorkflow():
[for (ps : ProcessingStep | aWorkflow.dataprocessing)]																										[comment OPEN traverse all the DataProcessings/]
	[if (ps.incoming = null and ps.outgoing=null)]																											[comment OPEN checks if the DataProcessing is isolated (no links)/]
	#-----------------New DataProcessing-----------------
		[if (ps.dataProcessingDefinition.oclIsKindOf(Library::DataProcessingDefinition))]																	[comment OPEN checks that it is a DataProcessingDefinition/]
			[let dpd : Library::DataProcessingDefinition = ps.dataProcessingDefinition.oclAsType(Library::DataProcessingDefinition)]						[comment OPEN assigns the variable to be a DataProcessingDefinition/]
				[if (dpd.oclIsKindOf(Library::Transformation))]																								[comment OPEN checks if the DataProcessingDefinition is a Transformation/]
					[let libT : Library::Transformation = dpd.oclAsType(Library::Transformation)]															[comment OPEN assigns the variable to be a Transformation/]
						[for (dc : DataDictionary | ps.inputPort)]																							[comment OPEN read all the input datasets and store them/]
							[if (aWorkflow.environment.oclIsKindOf(Local))]																					[comment OPEN checks if it is a container/]
	[dc.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet('[if (aWorkflow.environment.path.startsWith('.'))][aWorkflow.environment.path.replaceFirst('./', '/')/][else][aWorkflow.environment.path/][/if]/data/[if not ps.oclAsType(DataProcessing).initial_accumulated_processing->isEmpty()][if (ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.trim().indexOf('.')>0)][ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.trim()/].parquet[/if][else][if (dc.fileName.trim().indexOf('.')>0)][dc.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dc.fileName.trim()/].parquet[/if][/if]')
							[/if]																															[comment CLOSE checks if it is a local file and a container or a local environment/]

						[/for]																																[comment CLOSE read all the input datasets and store them/]
						[for (dc : DataDictionary | ps.outputPort)]																							[comment OPEN read all the output datasets and store them/]
							[if (aWorkflow.environment.oclIsKindOf(Local))]																					[comment OPEN checks if it is a local file and a container/]
	if os.path.exists('[if (aWorkflow.environment.path.startsWith('.'))][aWorkflow.environment.path.replaceFirst('./', '/')/][else][aWorkflow.environment.path/][/if]/data/[if (dc.fileName.trim().indexOf('.')>0)][dc.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dc.fileName.trim()/].parquet[/if]'):
		[dc.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet('[if (aWorkflow.environment.path.startsWith('.'))][aWorkflow.environment.path.replaceFirst('./', '/')/][else][aWorkflow.environment.path/][/if]/data/[if (dc.fileName.trim().indexOf('.')>0)][dc.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dc.fileName.trim()/].parquet[/if]')
							[/if]																															[comment CLOSE checks if it is a local file and a container or a local environment/]

						[/for]																																[comment CLOSE read all the output datasets and store them/]
						[if (ps.oclIsKindOf(DataProcessing))]																								[comment OPEN checks if the actual ProcessingStep is a DataProcessing/]
							[let d : DataProcessing = ps.oclAsType(DataProcessing)]																			[comment OPEN assigns the variable to be a DataProcessing/]
	[generateDataSmells(d)/]
								[for (c : Contract | d.contract)]																							[comment OPEN traverse all the contracts in the DataProcessing/]
									[if (c.contract.oclIsTypeOf(ValueRange))]
										[if (c.contract.oclAsType(Contract::ValueRange).valueRangeDef.type=ContractType::PRECONDITION)]						[comment OPEN checks if the if the contract is a Precondition/]
	[generateCallContract(c.contract, d)/]
										[/if]																												[comment CLOSE checks if the if the contract is a Precondition/]
									[elseif (c.contract.oclIsTypeOf(FieldRange))]
										[if (c.contract.oclAsType(Contract::FieldRange).fieldRangeDef.type=ContractType::PRECONDITION)]						[comment OPEN checks if the if the contract is a Precondition/]
	[generateCallContract(c.contract, d)/]
										[/if]																												[comment CLOSE checks if the if the contract is a Precondition/]
									[/if]
								[/for]																														[comment CLOSE traverse all the contracts in the DataProcessing/]
								[for (c : Contract | d.contract)]																							[comment OPEN traverse all the contracts in the DataProcessing/]
									[if (c.contract.oclIsTypeOf(ValueRange))]
										[if (c.contract.oclAsType(Contract::ValueRange).valueRangeDef.type=ContractType::POSTCONDITION)]					[comment OPEN checks if the if the contract is a Postcondition/]
	[generateCallContract(c.contract, d)/]
										[/if]																												[comment CLOSE checks if the if the contract is a Postcondition/]
									[elseif (c.contract.oclIsTypeOf(FieldRange))]
										[if (c.contract.oclAsType(Contract::FieldRange).fieldRangeDef.type=ContractType::POSTCONDITION)]					[comment OPEN checks if the if the contract is a Postcondition/]
	[generateCallContract(c.contract, d)/]
										[/if]																												[comment CLOSE checks if the if the contract is a Precondition/]
									[/if]																													[comment CLOSE checks if the if the contract is a Postcondition/]
								[/for]																														[comment CLOSE traverse all the contracts in the DataProcessing/]
								[for (c : Contract | d.contract)]																							[comment OPEN traverse all the contracts in the DataProcessing/]
									[if (c.contract.oclIsTypeOf(Condition))]
										[if (c.contract.oclAsType(Contract::Condition).conditionDef.type=ContractType::INVARIANT)]							[comment OPEN checks if the if the contract is a Invariant/]
	[generateCallContract(c.contract, d)/]
										[/if]																												[comment CLOSE checks if the if the contract is a Invariant/]
									[/if]																													[comment CLOSE checks if the if the contract is a Invariant/]
								[/for]																														[comment CLOSE traverse all the contracts in the DataProcessing/]
							[/let]																															[comment CLOSE assigns the variable to be a DataProcessing/]
						[/if]																																[comment CLOSE checks if the actual ProcessingStep is a DataProcessing/]
						[if (ps.oclIsKindOf(PMMLModel))]																									[comment OPEN checks if the actual ProcessingStep is a PMMLModel/]
							[let pmml : PMMLModel = ps.oclAsType(PMMLModel)]																				[comment OPEN assigns the variable to be a PMMLModel/]
	[generatePMML(pmml, ps)/]
							[/let]																															[comment CLOSE assigns the variable to be a PMMLModel/]
						[/if]																																[comment CLOSE checks if the actual ProcessingStep is a PMMLModel/]
					[/let]																																	[comment CLOSE assigns the variable to be a Transformation/]
				[elseif (dpd.oclIsKindOf(Library::Job))]																									[comment OPEN checks if the DataProcessingDefinition is a Job/]
					[let libJ : Library::Job = dpd.oclAsType(Library::Job)]																					[comment OPEN assigns the variable to be a Job/]
	#--------------------------------------Input data dictionaries--------------------------------------
						[for (arg : Argument | ps._in)]																										[comment OPEN traverse all the input arguments/]
							[if (arg.oclIsKindOf(DataDictionary))]																							[comment OPEN checks if the argument is a DataDictionary/]
								[let dd_in : DataDictionary = arg.oclAsType(DataDictionary)]																[comment OPEN assigns the variable to be a DataDictionary/]
									[if (aWorkflow.environment.oclIsKindOf(Local))]																			[comment OPEN checks if it is a local file and a container/]
	[dd_in.dataDictionaryDefinition.boundTo.name.replaceAll('[(),-/\\s]+', '_')/]='[if (aWorkflow.environment.path.startsWith('.'))][aWorkflow.environment.path.replaceFirst('./', '/')/][else][aWorkflow.environment.path/][/if]/data/[if not ps.oclAsType(DataProcessing).initial_accumulated_processing->isEmpty()][if (ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.trim().indexOf('.')>0)][ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.trim()/].parquet[/if][else][if (dd_in.fileName.trim().indexOf('.')>0)][dd_in.fileName.replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_in.fileName.trim()/].parquet[/if][/if]'
									[/if]																													[comment CLOSE checks if it is a local file and a container or a local environment/]
								[/let]																														[comment CLOSE assigns the variable to be a DataDictionary/]
							[/if]																															[comment CLOSE checks if the argument is a DataDictionary/]
						[/for]																																[comment CLOSE traverse all the input arguments/]
	#--------------------------------------Output data dictionaries--------------------------------------
						[for (arg : Argument | ps.out)]																										[comment OPEN traverse all the output arguments/]
							[if (arg.oclIsKindOf(DataDictionary))]																							[comment OPEN checks if the argument is a DataDictionary/]
								[let dd_out : DataDictionary = arg.oclAsType(DataDictionary)]																[comment OPEN assigns the variable to be a DataDictionary/]
									[if (aWorkflow.environment.oclIsKindOf(Local))]																			[comment OPEN checks if it is a local file and a container/]
	[dd_out.dataDictionaryDefinition.boundTo.name.replaceAll('[(),-/\\s]+', '_')/]='[if (aWorkflow.environment.path.startsWith('.'))][aWorkflow.environment.path.replaceFirst('./', '/')/][else][aWorkflow.environment.path/][/if]/data/[if (dd_out.fileName.trim().indexOf('.')>0)][dd_out.fileName.replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_out.fileName.trim()/].parquet[/if]'
									[/if]																													[comment CLOSE checks if it is a local file and a container or a local environment/]
								[/let]																														[comment CLOSE assigns the variable to be a DataDictionary/]
							[/if]																															[comment CLOSE checks if the argument is a DataDictionary/]
						[/for]																																[comment CLOSE traverse all the input arguments/]

						[if (ps.oclIsKindOf(DataProcessing))]																								[comment OPEN checks if the actual ProcessingStep is a DataProcessing/]
							[let d : DataProcessing = ps.oclAsType(DataProcessing)]																			[comment OPEN assigns the variable to be a DataProcessing/]
								[for (pstep : ProcessingStep | libJ.workflow.dataprocessing)]																[comment OPEN traverse all the dataProcessing in the workflow/]
									[if (pstep.incoming = null and pstep.outgoing=null)]																	[comment OPEN checks if the dataProcessing is isolated/]
										[if (pstep.oclIsKindOf(DataProcessing))]																			[comment OPEN checks if the original ProcessingStep is a DataProcessing/]
											[let dataP : DataProcessing = pstep.oclAsType(DataProcessing)]													[comment OPEN assigns the variable to be a DataProcessing/]
	[generateDataSmells(d)/]
												[for (c : Contract | dataP.contract)]																		[comment OPEN traverse all the contracts in the DataProcessing/]
													[if (c.contract.oclIsTypeOf(ValueRange))]
														[if (c.contract.oclAsType(Contract::ValueRange).valueRangeDef.type=ContractType::PRECONDITION)]		[comment OPEN checks if the if the contract is a Precondition/]
	[generateCallContract(c.contract, d)/]
														[/if]																								[comment CLOSE checks if the if the contract is a Precondition/]
													[elseif (c.contract.oclIsTypeOf(FieldRange))]
														[if (c.contract.oclAsType(Contract::FieldRange).fieldRangeDef.type=ContractType::PRECONDITION)]		[comment OPEN checks if the if the contract is a Precondition/]
	[generateCallContract(c.contract, d)/]
														[/if]																								[comment CLOSE checks if the if the contract is a Precondition/]
													[/if]
												[/for]																										[comment CLOSE traverse all the contracts in the DataProcessing/]
												[for (c : Contract | dataP.contract)]																		[comment OPEN traverse all the contracts in the DataProcessing/]
													[if (c.contract.oclIsTypeOf(ValueRange))]
														[if (c.contract.oclAsType(Contract::ValueRange).valueRangeDef.type=ContractType::POSTCONDITION)]	[comment OPEN checks if the if the contract is a Postcondition/]
	[generateCallContract(c.contract, d)/]
														[/if]																								[comment CLOSE checks if the if the contract is a Postcondition/]
													[elseif (c.contract.oclIsTypeOf(FieldRange))]
														[if (c.contract.oclAsType(Contract::FieldRange).fieldRangeDef.type=ContractType::POSTCONDITION)]	[comment OPEN checks if the if the contract is a Postcondition/]
	[generateCallContract(c.contract, d)/]
														[/if]																								[comment CLOSE checks if the if the contract is a Precondition/]
													[/if]																									[comment CLOSE checks if the if the contract is a Postcondition/]
												[/for]																										[comment CLOSE traverse all the contracts in the DataProcessing/]
												[for (c : Contract | dataP.contract)]																		[comment OPEN traverse all the contracts in the DataProcessing/]
													[if (c.contract.oclIsTypeOf(Condition))]
														[if (c.contract.oclAsType(Contract::Condition).conditionDef.type=ContractType::INVARIANT)]			[comment OPEN checks if the if the contract is a Invariant/]
	[generateCallContract(c.contract, d)/]
														[/if]																								[comment CLOSE checks if the if the contract is a Invariant/]
													[/if]																									[comment CLOSE checks if the if the contract is a Invariant/]
												[/for]																										[comment CLOSE traverse all the contracts in the DataProcessing/]
											[/let]																											[comment CLOSE assigns the variable to be a DataProcessing/]
										[/if]																												[comment CLOSE checks if the original ProcessingStep is a DataProcessing/]
										[if (pstep.oclIsKindOf(PMMLModel))]																					[comment OPEN checks if the original ProcessingStep is a PMMLModel/]
											[let pmml : PMMLModel = pstep.oclAsType(PMMLModel)]																[comment OPEN assigns the variable to be a PMMLModel/]
	[generatePMML(pmml, ps)/]
											[/let]																											[comment CLOSE assigns the variable to be a PMMLModel/]
										[/if]																												[comment CLOSE checks if the original ProcessingStep is a PMMLModel/]
									[/if]																													[comment CLOSE checks if the dataProcessing is isolated/]
								[/for]																														[comment CLOSE traverse all the dataProcessing in the workflow/]
								[for (pstep : ProcessingStep | libJ.workflow.dataprocessing)]																[comment OPEN traverse all the dataProcessing in the workflow/]
									[if (pstep.incoming = null and pstep.outgoing<>null)]																	[comment OPEN checks if it is the first dataProcessing and is not isolated/]
[callContractsModifiedRecursiveTemplate(pstep, ps)/]
									[/if]																													[comment CLOSE checks if it is the first dataProcessing and is not isolated/]
								[/for]																														[comment CLOSE traverse all the dataProcessing in the workflow/]
							[/let]																															[comment CLOSE assigns the variable to be a DataProcessing/]
						[/if]																																[comment CLOSE checks if the actual ProcessingStep is a DataProcessing/]
					[/let]																																	[comment CLOSE assigns the variable to be a Transformation/]
				[/if]																																		[comment CLOSE checks if the DataProcessingDefinition is a Transformation or a Job/]
			[/let]																																			[comment CLOSE assigns the variable to be a DataProcessingDefinition/]
		[/if]																																				[comment CLOSE checks that it is a DataProcessingDefinition/]
	[/if]																																					[comment CLOSE checks if the DataProcessing is isolated (no links)/]
[/for]																																						[comment CLOSE traverse all the DataProcessings/]
[for (ps : ProcessingStep | aWorkflow.dataprocessing)]																										[comment OPEN traverse all the DataProcessings/]
	[if (ps.incoming = null and ps.outgoing<>null)]																											[comment OPEN checks if the DataProcessing is the first (no input link, an output link)/]
		[if (ps.dataProcessingDefinition.oclIsKindOf(Library::DataProcessingDefinition))]																	[comment OPEN assigns the variable to be a DataProcessingDefinition/]
			[let dpd : Library::DataProcessingDefinition = ps.dataProcessingDefinition.oclAsType(Library::DataProcessingDefinition)]						[comment OPEN assigns the variable to be a DataProcessingDefinition/]
				[if (dpd.oclIsKindOf(Library::Transformation))]																								[comment OPEN checks if the DataProcessingDefinition is a Transformation/]
					[let libT : Library::Transformation = dpd.oclAsType(Library::Transformation)]															[comment OPEN assigns the variable to be a Transformation/]
[callContractsRecursiveTemplate(ps)/]
					[/let]																																	[comment CLOSE assigns the variable to be a Transformation/]
				[elseif (dpd.oclIsKindOf(Library::Job))]																									[comment OPEN assigns the variable to be a Job/]
					[let libJ : Library::Job = dpd.oclAsType(Library::Job)]																					[comment OPEN assigns the variable to be a Job/]
	#--------------------------------------Input data dictionaries--------------------------------------
						[for (arg : Argument | ps._in)]																										[comment OPEN traverse all the input arguments/]
							[if (arg.oclIsKindOf(DataDictionary))]																							[comment OPEN checks if the argument is a DataDictionary/]
								[let dd_in : DataDictionary = arg.oclAsType(DataDictionary)]																[comment OPEN assigns the variable to be a DataDictionary/]
									[if (aWorkflow.environment.oclIsKindOf(Local))]																			[comment OPEN checks if it is a local file and a container/]
	[dd_in.dataDictionaryDefinition.boundTo.name.replaceAll('[(),-/\\s]+', '_')/]='[if (aWorkflow.environment.path.startsWith('.'))][aWorkflow.environment.path.replaceFirst('./', '/')/][else][aWorkflow.environment.path/][/if]/data/[if not ps.oclAsType(DataProcessing).initial_accumulated_processing->isEmpty()][if (ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.trim().indexOf('.')>0)][ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.trim()/].parquet[/if][else][if (dd_in.fileName.trim().indexOf('.')>0)][dd_in.fileName.replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_in.fileName.trim()/].parquet[/if][/if]'
									[/if]																													[comment CLOSE checks if it is a local file and a container or a local environment/]
								[/let]																														[comment CLOSE assigns the variable to be a DataDictionary/]
							[/if]																															[comment CLOSE checks if the argument is a DataDictionary/]
						[/for]																																[comment CLOSE traverse all the input arguments/]
	#--------------------------------------Output data dictionaries--------------------------------------
						[for (arg : Argument | ps.out)]																										[comment OPEN traverse all the output arguments/]
							[if (arg.oclIsKindOf(DataDictionary))]																							[comment OPEN checks if the argument is a DataDictionary/]
								[let dd_out : DataDictionary = arg.oclAsType(DataDictionary)]																[comment OPEN assigns the variable to be a DataDictionary/]
									[if (aWorkflow.environment.oclIsKindOf(Local))]																			[comment OPEN checks if it is a local file and a container/]
	[dd_out.dataDictionaryDefinition.boundTo.name.replaceAll('[(),-/\\s]+', '_')/]='[if (aWorkflow.environment.path.startsWith('.'))][aWorkflow.environment.path.replaceFirst('./', '/')/][else][aWorkflow.environment.path/][/if]/data/[if (dd_out.fileName.trim().indexOf('.')>0)][dd_out.fileName.replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_out.fileName.trim()/].parquet[/if]'
									[/if]																													[comment CLOSE checks if it is a local file and a container or a local environment/]
								[/let]																														[comment CLOSE assigns the variable to be a DataDictionary/]
							[/if]																															[comment CLOSE checks if the argument is a DataDictionary/]
						[/for]																																[comment CLOSE traverse all the output arguments/]

						[if (ps.oclIsKindOf(DataProcessing))]																								[comment OPEN checks if the actual ProcessingStep is a DataProcessing/]
							[let d : DataProcessing = ps.oclAsType(DataProcessing)]																			[comment OPEN assigns the variable to be a DataProcessing/]
								[for (pstep : ProcessingStep | libJ.workflow.dataprocessing)]																[comment OPEN traverse all the DataProcessings/]
									[if (pstep.incoming = null and pstep.outgoing=null)]																	[comment OPEN checks if the dataProcessing is isolated/]
										[if (pstep.oclIsKindOf(DataProcessing))]																			[comment OPEN checks if the original ProcessingStep is a DataProcessing/]
											[let dataP : DataProcessing = pstep.oclAsType(DataProcessing)]													[comment OPEN assigns the variable to be a DataProcessing/]
	[generateDataSmells(d)/]
												[for (c : Contract | dataP.contract)]																		[comment OPEN traverse all the contracts in the DataProcessing/]
													[if (c.contract.oclIsTypeOf(ValueRange))]
														[if (c.contract.oclAsType(Contract::ValueRange).valueRangeDef.type=ContractType::PRECONDITION)]		[comment OPEN checks if the if the contract is a Precondition/]
	[generateCallContract(c.contract, d)/]
														[/if]																								[comment CLOSE checks if the if the contract is a Precondition/]
													[elseif (c.contract.oclIsTypeOf(FieldRange))]
														[if (c.contract.oclAsType(Contract::FieldRange).fieldRangeDef.type=ContractType::PRECONDITION)]		[comment OPEN checks if the if the contract is a Precondition/]
	[generateCallContract(c.contract, d)/]
														[/if]																								[comment CLOSE checks if the if the contract is a Precondition/]
													[/if]
												[/for]																										[comment CLOSE traverse all the contracts in the DataProcessing/]
												[for (c : Contract | dataP.contract)]																		[comment OPEN traverse all the contracts in the DataProcessing/]
													[if (c.contract.oclIsTypeOf(ValueRange))]
														[if (c.contract.oclAsType(Contract::ValueRange).valueRangeDef.type=ContractType::POSTCONDITION)]	[comment OPEN checks if the if the contract is a Postcondition/]
	[generateCallContract(c.contract, d)/]
														[/if]																								[comment CLOSE checks if the if the contract is a Postcondition/]
													[elseif (c.contract.oclIsTypeOf(FieldRange))]
														[if (c.contract.oclAsType(Contract::FieldRange).fieldRangeDef.type=ContractType::POSTCONDITION)]	[comment OPEN checks if the if the contract is a Postcondition/]
	[generateCallContract(c.contract, d)/]
														[/if]																								[comment CLOSE checks if the if the contract is a Precondition/]
													[/if]																									[comment CLOSE checks if the if the contract is a Postcondition/]
												[/for]																										[comment CLOSE traverse all the contracts in the DataProcessing/]
												[for (c : Contract | dataP.contract)]																		[comment OPEN traverse all the contracts in the DataProcessing/]
													[if (c.contract.oclIsTypeOf(Condition))]
														[if (c.contract.oclAsType(Contract::Condition).conditionDef.type=ContractType::INVARIANT)]			[comment OPEN checks if the if the contract is a Invariant/]
	[generateCallContract(c.contract, d)/]
														[/if]																								[comment CLOSE checks if the if the contract is a Invariant/]
													[/if]																									[comment CLOSE checks if the if the contract is a Invariant/]
												[/for]																										[comment CLOSE traverse all the contracts in the DataProcessing/]
											[/let]																											[comment CLOSE assigns the variable to be a DataProcessing/]
										[/if]																												[comment CLOSE checks if the original ProcessingStep is a DataProcessing/]
										[if (pstep.oclIsKindOf(PMMLModel))]																					[comment OPEN checks if the original ProcessingStep is a PMMLModel/]
											[let pmml : PMMLModel = pstep.oclAsType(PMMLModel)]																[comment OPEN assigns the variable to be a PMMLModel/]
	[generatePMML(pmml, ps)/]
											[/let]																											[comment CLOSE assigns the variable to be a PMMLModel/]
										[/if]																												[comment CLOSE checks if the original ProcessingStep is a PMMLModel/]
									[/if]																													[comment CLOSE checks if the dataProcessing is isolated/]
								[/for]																														[comment CLOSE traverse all the DataProcessings/]
								[for (pstep : ProcessingStep | libJ.workflow.dataprocessing)]																[comment OPEN traverse the dataProcessings in the workflow/]
									[if (pstep.incoming = null and pstep.outgoing<>null)]																	[comment OPEN checks if the dataProcessing is isolated/]
[callModifiedRecursiveTemplate(pstep, ps)/]
									[/if]																													[comment CLOSE checks that the dataProcessing is not isolated and is the first/]
								[/for]																														[comment CLOSE traverse all the DataProcessings/]
							[/let]																															[comment CLOSE assigns the variable to be a DataProcessing/]
						[/if]																																[comment CLOSE checks if the actual ProcessingStep is a DataProcessing/]
						[if (ps.oclIsKindOf(PMMLModel))]																									[comment OPEN checks if the actual ProcessingStep is a PMMLModel/]
							[for (pstep : ProcessingStep | libJ.workflow.dataprocessing)]																	[comment OPEN traverse the dataProcessings in the workflow/]
								[if (pstep.incoming = null and pstep.outgoing<>null)]																		[comment OPEN checks if the dataProcessing is isolated/]
[callModifiedRecursiveTemplate(pstep, ps)/]
								[/if]																														[comment CLOSE checks that the dataProcessing is not isolated and is the first/]
							[/for]																															[comment CLOSE traverse the dataProcessings in the workflow/]
						[/if]																																[comment CLOSE checks if the actual ProcessingStep is a PMMLModel/]
					[/let]																																	[comment CLOSE assigns the variable to be a Transformation/]
				[/if]																																		[comment CLOSE checks if the DataProcessingDefinition is a Transformation or a Job/]
			[/let]																																			[comment CLOSE assigns the variable to be a DataProcessingDefinition/]
		[/if]																																				[comment CLOSE assigns the variable to be a DataProcessingDefinition/]
	[/if]																																					[comment CLOSE checks if the DataProcessing is the first (no input link, an output link)/]
[/for]																																						[comment CLOSE traverse all the DataProcessings/]
set_logger("contracts")
generateWorkflow()
[/file]
[/template]


[template public callContractsModifiedRecursiveTemplate(pstep : ProcessingStep, ps : ProcessingStep)] [comment]pstep, dw, dataP son el modelo grande. El que tiene todos los dataProcessing con las transformaciones y los contratos[/comment]
	#-----------------New DataProcessing-----------------
[if (pstep.incoming <> null)]																		[comment OPEN checks if there is a previous DataProcessing/]
	[if (pstep.incoming.source.dataProcessingDefinition.name<>'split')]								[comment OPEN checks that the operation is not split/]
		[for (dc : DataDictionary | pstep.inputPort)]												[comment OPEN read all the input datasets and store them/]
			[if (ps.eContainer(Workflow).environment.oclIsKindOf(Local))]							[comment OPEN checks if it is a local file/]
	if os.path.exists([dc.name.replaceAll('[(),-/\\s]+', '_')/]):
		[dc.name.replaceAll('[(),-/\\s]+', '_')/]_df=[if not ps.oclAsType(DataProcessing).initial_accumulated_processing->isEmpty()]pd.read_parquet([ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().name.replaceAll('[(),-/\\s]+', '_')/])[else]pd.read_parquet([dc.name.replaceAll('[(),-/\\s]+', '_')/])[/if]
						
			[/if]																					[comment CLOSE checks if it is a local file/]
		[/for]																						[comment CLOSE read all the input datasets and store them/]

		[for (dc : DataDictionary | pstep.outputPort)]												[comment OPEN read all the output datasets and store them/]
			[if (ps.eContainer(Workflow).environment.oclIsKindOf(Local))]							[comment OPEN checks if it is a local file and a container/]
	if os.path.exists([dc.name.replaceAll('[(),-/\\s]+', '_')/]):
		[dc.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet([dc.name.replaceAll('[(),-/\\s]+', '_')/])
			[/if]																					[comment CLOSE checks if it is a local file and a container/]
			
		[/for]																						[comment CLOSE read all the output datasets and store them/]
	[else]																							[comment OPEN checks if the operation is split/]
		[for (dc : DataDictionary | pstep.inputPort)]												[comment OPEN read all the input datasets and store them/]
			[for (dc_out : DataDictionary | pstep.incoming.source.outputPort)]						[comment OPEN read the previous DataProcessing output datasets/]
				[if (dc.fileName.trim() = dc_out.fileName)]											[comment OPEN checks that both datasets are the same/]
	[dc.name.replaceAll('[(),-/\\s]+', '_')/]_df=[if not ps.oclAsType(DataProcessing).initial_accumulated_processing->isEmpty()]pd.read_parquet([ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().name.replaceAll('[(),-/\\s]+', '_')/])[else]pd.read_parquet([dc.name.replaceAll('[(),-/\\s]+', '_')/])[/if]

				[/if]																				[comment CLOSE checks that both datasets are the same/]
			[/for]																					[comment CLOSE read the previous DataProcessing output datasets/]
		[/for]																						[comment CLOSE read all the input datasets and store them/]
	[/if]																							[comment CLOSE checks if the operation is split or not/]
[else]																								[comment OPEN checks that there is not a previous DataProcessing/]
	[for (dc : DataDictionary | pstep.inputPort)]													[comment OPEN read all the input datasets and store them/]
		[if (ps.eContainer(Workflow).environment.oclIsKindOf(Local))]								[comment OPEN checks if it is a local file and a container/]
	[dc.name.replaceAll('[(),-/\\s]+', '_')/]_df=[if not ps.oclAsType(DataProcessing).initial_accumulated_processing->isEmpty()]pd.read_parquet([ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().name.replaceAll('[(),-/\\s]+', '_')/])[else]pd.read_parquet([dc.name.replaceAll('[(),-/\\s]+', '_')/])[/if]
		[/if]

	[/for]																							[comment CLOSE read all the input datasets and store them/]
	[for (dc : DataDictionary | pstep.outputPort)]													[comment OPEN read all the output datasets and store them/]
		[if (ps.eContainer(Workflow).environment.oclIsKindOf(Local))]								[comment OPEN checks if it is a local file/]
	if os.path.exists([dc.name.replaceAll('[(),-/\\s]+', '_')/]):
		[dc.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet([dc.name.replaceAll('[(),-/\\s]+', '_')/])
		[/if]																						[comment CLOSE checks if it is a local file/]
			
	[/for]																							[comment CLOSE read all the output datasets and store them/]
[/if]																								[comment CLOSE checks if there is a previous DataProcessingor not/]
[if (pstep.oclIsKindOf(DataProcessing))]															[comment OPEN checks if the original ProcessingStep is a DataProcessing/]
	[let dw : DataProcessing = pstep.oclAsType(DataProcessing)]										[comment OPEN assigns the variable to be a DataProcessing/]
		[if (ps.oclIsKindOf(DataProcessing))]														[comment OPEN checks if the actual ProcessingStep is a DataProcessing/]
			[let d_or : DataProcessing = ps.oclAsType(DataProcessing)]								[comment OPEN assigns the variable to be a DataProcessing/]
	[generateDataSmells(d_or)/]
				[for (c : Contract | dw.contract)]													[comment OPEN traverse all the contracts in the DataProcessing/]
					[if (c.contract.oclIsTypeOf(ValueRange))]
						[if (c.contract.oclAsType(Contract::ValueRange).valueRangeDef.type=ContractType::PRECONDITION)]		[comment OPEN checks if the if the contract is a Precondition/]
	[generateCallContract(c.contract, d_or)/]
						[/if]																		[comment CLOSE checks if the if the contract is a Precondition/]
					[elseif (c.contract.oclIsTypeOf(FieldRange))]
						[if (c.contract.oclAsType(Contract::FieldRange).fieldRangeDef.type=ContractType::PRECONDITION)]		[comment OPEN checks if the if the contract is a Precondition/]
	[generateCallContract(c.contract, d_or)/]
						[/if]																		[comment CLOSE checks if the if the contract is a Precondition/]
					[/if]
				[/for]																				[comment CLOSE traverse all the contracts in the DataProcessing/]
				[for (c : Contract | dw.contract)]													[comment OPEN traverse all the contracts in the DataProcessing/]
					[if (c.contract.oclIsTypeOf(ValueRange))]
						[if (c.contract.oclAsType(Contract::ValueRange).valueRangeDef.type=ContractType::POSTCONDITION)]	[comment OPEN checks if the if the contract is a Postcondition/]
	[generateCallContract(c.contract, d_or)/]
						[/if]																		[comment CLOSE checks if the if the contract is a Postcondition/]
					[elseif (c.contract.oclIsTypeOf(FieldRange))]
						[if (c.contract.oclAsType(Contract::FieldRange).fieldRangeDef.type=ContractType::POSTCONDITION)]	[comment OPEN checks if the if the contract is a Postcondition/]
	[generateCallContract(c.contract, d_or)/]
						[/if]																		[comment CLOSE checks if the if the contract is a Precondition/]
					[/if]																			[comment CLOSE checks if the if the contract is a Postcondition/]
				[/for]																				[comment CLOSE traverse all the contracts in the DataProcessing/]
				[for (c : Contract | dw.contract)]													[comment OPEN traverse all the contracts in the DataProcessing/]
					[if (c.contract.oclIsTypeOf(Condition))]
						[if (c.contract.oclAsType(Contract::Condition).conditionDef.type=ContractType::INVARIANT)]			[comment OPEN checks if the if the contract is a Invariant/]
	[generateCallContract(c.contract, d_or)/]
						[/if]																		[comment CLOSE checks if the if the contract is a Invariant/]
					[/if]																			[comment CLOSE checks if the if the contract is a Invariant/]
				[/for]																				[comment CLOSE traverse all the contracts in the DataProcessing/]
			[/let]																					[comment CLOSE assigns the variable to be a DataProcessing/]
		[/if]																						[comment CLOSE checks if the actual ProcessingStep is a DataProcessing/]
	[/let]																							[comment CLOSE assigns the variable to be a DataProcessing/]
[elseif (pstep.oclIsKindOf(PMMLModel))]																[comment OPEN checks if the original ProcessingStep is a PMMLModel/]
	[let pmml : PMMLModel = pstep.oclAsType(PMMLModel)]												[comment OPEN assigns the variable to be a PMMLModel/]
	[generatePMML(pmml, ps)/]
	[/let]																							[comment CLOSE assigns the variable to be a PMMLModel/]
[/if]																								[comment CLOSE checks if the original ProcessingStep is a DataProcessing or a PMMLModel/]
[if (pstep.outgoing<>null)]																			[comment OPEN checks if the DataProcessing has an outgoing link (it's not the last)/]
	[let nextPstep : ProcessingStep = pstep.outgoing.target]										[comment OPEN assigns the next DataProcessing to a variable/]
[callContractsModifiedRecursiveTemplate(nextPstep, ps)/]			[comment Recursive call to this template to generate all the DataProcessings linked to the first/]
	[/let]																							[comment CLOSE assigns the next DataProcessing to a variable/]
[/if]																								[comment CLOSE checks if the DataProcessing has an outgoing link (it's not the last)/]
[/template]


[template public callContractsRecursiveTemplate(ps : ProcessingStep)]
	#-----------------New DataProcessing-----------------
[if (ps.incoming <> null)]																										[comment OPEN checks if there is a previous DataProcessing/]
	[if (ps.incoming.source.dataProcessingDefinition.name<>'split')]															[comment OPEN checks that the operation is not split/]
		[if (ps.eContainer(Workflow).environment.oclIsKindOf(Local))]															[comment OPEN checks if it is a local file and/]
			[for (dd_in : DataDictionary | ps.inputPort)]																		[comment OPEN traverse all the input DataDictionaries in the ProcessingStep/]
	[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df=[if not ps.oclAsType(DataProcessing).initial_accumulated_processing->isEmpty()]pd.read_parquet('[if (ps.oclAsType(DataProcessing).initial_accumulated_processing.eContainer(Workflow).environment.path.startsWith('.'))][ps.oclAsType(DataProcessing).initial_accumulated_processing.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][ps.oclAsType(DataProcessing).initial_accumulated_processing.eContainer(Workflow).environment.path/][/if]/data/[if (ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.trim().indexOf('.')>0)][ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.trim()/].parquet[/if]')[else]pd.read_parquet('[if (ps.eContainer(Workflow).environment.path.startsWith('.'))][ps.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][ps.eContainer(Workflow).environment.path/][/if]/data/[if (dd_in.fileName.trim().indexOf('.')>0)][dd_in.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_in.fileName.trim()/].parquet[/if]')[/if]
			[/for]																												[comment CLOSE traverse all the input DataDictionaries in the ProcessingStep/]
		[/if]																													[comment CLOSE checks if it is a local file/]

	[else]																														[comment OPEN checks if the operation is split/]
		[for (dc : DataDictionary | ps.inputPort)]																				[comment OPEN read all the input datasets and store them/]
			[for (dc_out : DataDictionary | ps.incoming.source.outputPort)]														[comment OPEN read the previous DataProcessing output datasets/]
				[if (dc.fileName.trim() = dc_out.fileName)]																		[comment OPEN checks that both datasets are the same/]
					[if (ps.eContainer(Workflow).environment.oclIsKindOf(Local))]												[comment OPEN checks if it is a local file and a container/]
	[dc.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet('[if (ps.eContainer(Workflow).environment.path.startsWith('.'))][ps.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][ps.eContainer(Workflow).environment.path/][/if]/data/[if (dc_out.fileName.trim().indexOf('.')>0)][dc_out.fileName.replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dc_out.fileName/].parquet[/if]')
					[/if]																										[comment CLOSE checks if it is a local file and a container or a local environment/]

				[/if]																											[comment CLOSE checks that both datasets are the same/]
			[/for]																												[comment CLOSE read the previous DataProcessing output datasets/]
		[/for]																													[comment CLOSE read all the input datasets and store them/]
	[/if]																														[comment CLOSE checks that the operation is split or not/]
[else]																															[comment OPEN checks that there is not a previous DataProcessing/]
	[for (dc : DataDictionary | ps.inputPort)]																					[comment OPEN read all the input datasets and store them/]
		[if (ps.eContainer(Workflow).environment.oclIsKindOf(Local))]															[comment OPEN checks if it is a local file and a container/]
	[dc.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet('[if not ps.oclAsType(DataProcessing).initial_accumulated_processing->isEmpty()][if (ps.oclAsType(DataProcessing).initial_accumulated_processing.eContainer(Workflow).environment.path.startsWith('.'))][ps.oclAsType(DataProcessing).initial_accumulated_processing.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][ps.oclAsType(DataProcessing).initial_accumulated_processing.eContainer(Workflow).environment.path/][/if]/data/[if (ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.trim().indexOf('.')>0)][ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.trim()/].parquet[/if][else][if (ps.eContainer(Workflow).environment.path.startsWith('.'))][ps.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][ps.eContainer(Workflow).environment.path/][/if]/data/[if (dc.fileName.trim().indexOf('.')>0)][dc.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dc.fileName.trim()/].parquet[/if][/if]')
		[/if]																													[comment CLOSE checks if it is a local file and a container or a local environment/]
	[/for]																														[comment CLOSE read all the input datasets and store them/]
[/if]																															[comment CLOSE checks if there is a previous DataProcessingor not/]
[for (dc : DataDictionary | ps.outputPort)]																						[comment OPEN read all the output datasets and store them/]
	[if (ps.eContainer(Workflow).environment.oclIsKindOf(Local))]																[comment OPEN checks if it is a local file and a container/]
	if os.path.exists('[if (ps.eContainer(Workflow).environment.path.startsWith('.'))][ps.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][ps.eContainer(Workflow).environment.path/][/if]/data/[if (dc.fileName.trim().indexOf('.')>0)][dc.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dc.fileName.trim()/].parquet[/if]'):
		[dc.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet('[if (ps.eContainer(Workflow).environment.path.startsWith('.'))][ps.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][ps.eContainer(Workflow).environment.path/][/if]/data/[if (dc.fileName.trim().indexOf('.')>0)][dc.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dc.fileName.trim()/].parquet[/if]')
	[/if]																														[comment CLOSE checks if it is a local file and a container or a local environment/]

[/for]																															[comment CLOSE read all the output datasets and store them/]
[if (ps.oclIsKindOf(DataProcessing))]																							[comment OPEN checks if the actual ProcessingStep is a DataProcessing/]
	[let d : DataProcessing = ps.oclAsType(DataProcessing)]																		[comment OPEN assigns the variable to be a DataProcessing/]
	[generateDataSmells(d)/]
		[for (c : Contract | d.contract)]																						[comment OPEN traverse all the contracts in the DataProcessing/]
			[if (c.contract.oclIsTypeOf(ValueRange))]
				[if (c.contract.oclAsType(Contract::ValueRange).valueRangeDef.type=ContractType::PRECONDITION)]					[comment OPEN checks if the if the contract is a Precondition/]
	[generateCallContract(c.contract, d)/]
				[/if]																											[comment CLOSE checks if the if the contract is a Precondition/]
			[elseif (c.contract.oclIsTypeOf(FieldRange))]
				[if (c.contract.oclAsType(Contract::FieldRange).fieldRangeDef.type=ContractType::PRECONDITION)]					[comment OPEN checks if the if the contract is a Precondition/]
	[generateCallContract(c.contract, d)/]
				[/if]																											[comment CLOSE checks if the if the contract is a Precondition/]
			[/if]
		[/for]																													[comment CLOSE traverse all the contracts in the DataProcessing/]
		[for (c : Contract | d.contract)]																						[comment OPEN traverse all the contracts in the DataProcessing/]
			[if (c.contract.oclIsTypeOf(ValueRange))]
				[if (c.contract.oclAsType(Contract::ValueRange).valueRangeDef.type=ContractType::POSTCONDITION)]				[comment OPEN checks if the if the contract is a Postcondition/]
	[generateCallContract(c.contract, d)/]
				[/if]																											[comment CLOSE checks if the if the contract is a Postcondition/]
			[elseif (c.contract.oclIsTypeOf(FieldRange))]
				[if (c.contract.oclAsType(Contract::FieldRange).fieldRangeDef.type=ContractType::POSTCONDITION)]				[comment OPEN checks if the if the contract is a Postcondition/]
	[generateCallContract(c.contract, d)/]
				[/if]																											[comment CLOSE checks if the if the contract is a Precondition/]
			[/if]																												[comment CLOSE checks if the if the contract is a Postcondition/]
		[/for]																													[comment CLOSE traverse all the contracts in the DataProcessing/]
		[for (c : Contract | d.contract)]																						[comment OPEN traverse all the contracts in the DataProcessing/]
			[if (c.contract.oclIsTypeOf(Condition))]
				[if (c.contract.oclAsType(Contract::Condition).conditionDef.type=ContractType::INVARIANT)]						[comment OPEN checks if the if the contract is a Invariant/]
	[generateCallContract(c.contract, d)/]
				[/if]																											[comment CLOSE checks if the if the contract is a Invariant/]
			[/if]																												[comment CLOSE checks if the if the contract is a Invariant/]
		[/for]																													[comment CLOSE traverse all the contracts in the DataProcessing/]
	[/let]																														[comment CLOSE assigns the variable to be a DataProcessing/]
[elseif (ps.oclIsKindOf(PMMLModel))]																							[comment OPEN checks if the actual ProcessingStep is a PMMLModel/]
	[let pmml : PMMLModel = ps.oclAsType(PMMLModel)]																			[comment OPEN assigns the variable to be a PMMLModel/]
	[generatePMML(pmml, ps)/]
	[/let]																														[comment CLOSE assigns the variable to be a PMMLModel/]
[/if]																															[comment CLOSE checks if the actual ProcessingStep is a DataProcessing or a PMMLModel/]
[if (ps.outgoing<>null)]																										[comment OPEN checks if the DataProcessing has an outgoing link (it's not the last)/]
	[let nextps : ProcessingStep = ps.outgoing.target]																			[comment OPEN assigns the next DataProcessing to a variable/]
[callContractsRecursiveTemplate(nextps)/]											[comment Recursive call to this template to generate all the DataProcessings linked to the first/]
	[/let]																														[comment OPEN assigns the next DataProcessing to a variable/]
[/if]																															[comment CLOSE checks if the DataProcessing has an outgoing link (it's not the last)/]
[/template]


[template public generateTransformationsDataProcessing(aWorkflow : Workflow)]
[file ('transformations_Job_'+aWorkflow.name.replaceAll('[(),-/\\s]+', '_')+'.py', false, 'UTF-8')]
import pandas as pd
import numpy as np
import functions.data_transformations as data_transformations
import functions.data_smells as data_smells
from helpers.enumerations import Belong, Operator, Operation, SpecialType, DataType, DerivedType, Closure, FilterType, MapOperation, MathOperator
from helpers.logger import set_logger
import pyarrow
from functions.PMML import PMMLModel

[comment generate the imports and the class/]
def generateWorkflow():
[for (ps : ProcessingStep | aWorkflow.dataprocessing)]																					[comment OPEN traverse all the DataProcessings/]
	[if (ps.incoming = null and ps.outgoing=null)]																						[comment OPEN checks if the DataProcessing is isolated (no links)/]
	#-----------------New DataProcessing-----------------
		[if (ps.dataProcessingDefinition.oclIsKindOf(Library::DataProcessingDefinition))]												[comment OPEN checks if the dataProcessingDefinition is a dataProcessingDefinition/]
			[let dpd : Library::DataProcessingDefinition = ps.dataProcessingDefinition.oclAsType(Library::DataProcessingDefinition)]	[comment OPEN assigns the variable to be a dataProcessingDefinition/]
				[if (dpd.oclIsKindOf(Library::Transformation))]																			[comment OPEN checks if the dataProcessingDefinition is a Transformation/]
					[let libT : Library::Transformation = dpd.oclAsType(Library::Transformation)]										[comment OPEN assigns the variable to be a Tranformation/]
						[for (dc : DataDictionary | ps.inputPort)]																		[comment OPEN read all the input datasets and store them/]
							[if (aWorkflow.environment.oclIsKindOf(Local))]																[comment OPEN checks if it is a local file and a container/]
	[dc.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet('[if (aWorkflow.environment.path.startsWith('.'))][aWorkflow.environment.path.replaceFirst('./', '/')/][else][aWorkflow.environment.path/][/if]/data/[if not ps.oclAsType(DataProcessing).initial_accumulated_processing->isEmpty()][if (ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.trim().indexOf('.')>0)][ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.trim()/].parquet[/if][else][if (dc.fileName.trim().indexOf('.')>0)][dc.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dc.fileName.trim()/].parquet[/if][/if]')
							[/if]																										[comment CLOSE checks if it is a local file and a container or a local environment/]

						[/for]																											[comment CLOSE read all the input datasets and store them/]
						[if (ps.oclIsKindOf(DataProcessing))]																			[comment OPEN checks if the actual ProcessingStep is a DataProcessing/]
							[let d : DataProcessing = ps.oclAsType(DataProcessing)]														[comment OPEN assigns the variable to be a DataProcessing/]
	[generateDataSmells(d)/]

	[generateCallTransformation(d, d)/]
							[/let]																										[comment CLOSE assigns the variable to be a DataProcessing/]
						[/if]																											[comment CLOSE checks if the actual ProcessingStep is a DataProcessing/]
						[if (ps.oclIsKindOf(PMMLModel))]																				[comment OPEN checks if the actual ProcessingStep is a PMMLModel/]
							[let pmml : PMMLModel = ps.oclAsType(PMMLModel)]															[comment OPEN assigns the variable to be a PMMLModel/]
	[generatePMML(pmml, ps)/]
							[/let]																										[comment CLOSE assigns the variable to be a PMMLModel/]
						[/if]																											[comment CLOSE checks if the actual ProcessingStep is a PMMLModel/]
					[/let]																												[comment CLOSE assigns the variable to be a Tranformation/]
				[elseif (dpd.oclIsKindOf(Library::Job))]																				[comment OPEN checks if the dataProcessingDefinition is a Job/]
					[let libJ : Library::Job = dpd.oclAsType(Library::Job)]																[comment OPEN assigns the variable to be a Job/]
	#--------------------------------------Input data dictionaries--------------------------------------
						[for (arg : Argument | ps._in)]																					[comment OPEN traverse all the input arguments/]
							[if (arg.oclIsKindOf(DataDictionary))]																		[comment OPEN checks if it is a DataDictionary/]
								[let dd_in : DataDictionary = arg.oclAsType(DataDictionary)]											[comment OPEN assigns the variable to be a DataDictionary/]
									[if (aWorkflow.environment.oclIsKindOf(Local))]														[comment OPEN checks if it is a local file and a container/]
	[dd_in.dataDictionaryDefinition.boundTo.name.replaceAll('[(),-/\\s]+', '_')/]='[if (aWorkflow.environment.path.startsWith('.'))][aWorkflow.environment.path.replaceFirst('./', '/')/][else][aWorkflow.environment.path/][/if]/data/[if not ps.oclAsType(DataProcessing).initial_accumulated_processing->isEmpty()][if (ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.trim().indexOf('.')>0)][ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.trim()/].parquet[/if][else][if (dd_in.fileName.trim().indexOf('.')>0)][dd_in.fileName.replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_in.fileName.trim()/].parquet[/if][/if]'
									[/if]																								[comment CLOSE checks if it is a local file and a container or a local environment/]
								[/let]																									[comment CLOSE assigns the variable to be a DataDictionary/]
							[/if]																										[comment CLOSE checks if it is a DataDictionary/]
						[/for]																											[comment CLOSE traverse all the input arguments/]
	#--------------------------------------Output data dictionaries--------------------------------------
						[for (arg : Argument | ps.out)]																					[comment OPEN traverse all the output arguments/]
							[if (arg.oclIsKindOf(DataDictionary))]																		[comment OPEN checks if it is a DataDictionary/]
								[let dd_out : DataDictionary = arg.oclAsType(DataDictionary)]											[comment OPEN assigns the variable to be a DataDictionary/]
									[if (aWorkflow.environment.oclIsKindOf(Local))]														[comment OPEN checks if it is a local file and a container/]
	[dd_out.dataDictionaryDefinition.boundTo.name.replaceAll('[(),-/\\s]+', '_')/]='[if (aWorkflow.environment.path.startsWith('.'))][aWorkflow.environment.path.replaceFirst('./', '/')/][else][aWorkflow.environment.path/][/if]/data/[if (dd_out.fileName.trim().indexOf('.')>0)][dd_out.fileName.replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_out.fileName.trim()/].parquet[/if]'
									[/if]																								[comment CLOSE checks if it is a local file and a container or a local environment/]
								[/let]																									[comment CLOSE assigns the variable to be a DataDictionary/]
							[/if]																										[comment CLOSE checks if it is a DataDictionary/]
						[/for]																											[comment CLOSE traverse all the output arguments/]
						[if (ps.oclIsKindOf(DataProcessing))]																			[comment OPEN checks if the actual ProcessingStep is a DataProcessing/]
							[let d : DataProcessing = ps.oclAsType(DataProcessing)]														[comment OPEN assigns the variable to be a DataProcessing/]
								[for (pstep : ProcessingStep | libJ.workflow.dataprocessing)]											[comment OPEN traverse all the dataProcessing/]
									[if (pstep.oclIsKindOf(DataProcessing))]															[comment OPEN checks if the original ProcessingStep is a DataProcessing/]
										[let dp : DataProcessing = pstep.oclAsType(DataProcessing)]										[comment OPEN assigns the variable to be a DataProcessing/]
											[if (pstep.incoming = null and pstep.outgoing=null)]										[comment OPEN checks if it is isolated/]
[generateDataSmells(d)/]

[generateCallTransformation(dp, d)/]
											[/if]																						[comment CLOSE checks if it is isolated/]
										[/let]																							[comment CLOSE assigns the variable to be a DataProcessing/]
									[/if]																								[comment CLOSE checks if the original ProcessingStep is a DataProcessing/]
								[/for]																									[comment CLOSE traverse all the dataProcessing/]
								[for (pstep : ProcessingStep | libJ.workflow.dataprocessing)]											[comment OPEN traverse all the dataProcessing/]
									[if (pstep.incoming = null and pstep.outgoing<>null)]												[comment OPEN checks if it is the first dataProcessing/]
[callTransformationsModifiedRecursiveTemplate(pstep, ps)/]
									[/if]																								[comment CLOSE checks if it is the first dataProcessing/]
								[/for]																									[comment CLOSE traverse all the dataProcessing/]
							[/let]																										[comment CLOSE assigns the variable to be a DataProcessing/]
						[/if]																											[comment CLOSE checks if the actual ProcessingStep is a DataProcessing/]
					[/let]																												[comment CLOSE assigns the variable to be a Job/]
				[/if]																													[comment CLOSE checks if the dataProcessingDefinition is a Transformation or a Job/]
			[/let]																														[comment CLOSE assigns the variable to be a dataProcessingDefinition/]
		[/if]																															[comment CLOSE checks if the dataProcessingDefinition is a dataProcessingDefinition/]
	[/if]																																[comment CLOSE checks if the DataProcessing is isolated (no links)/]
[/for]																																	[comment CLOSE traverse all the DataProcessings/]

[for (ps : ProcessingStep | aWorkflow.dataprocessing)]																					[comment OPEN traverse all the DataProcessings/]
	[if (ps.incoming = null and ps.outgoing<>null)]																						[comment OPEN checks if the DataProcessing is the first (no input link, an output link)/]
		[if (ps.dataProcessingDefinition.oclIsKindOf(Library::DataProcessingDefinition))]												[comment OPEN checks if the dataProcessingDefinition is a dataProcessingDefinition/]
			[let dpd : Library::DataProcessingDefinition = ps.dataProcessingDefinition.oclAsType(Library::DataProcessingDefinition)]	[comment OPEN assigns the variable to be a dataProcessingDefinition/]
				[if (dpd.oclIsKindOf(Library::Transformation))]																			[comment OPEN checks if the dataProcessingDefinition is a Transformation/]
					[let libT : Library::Transformation = dpd.oclAsType(Library::Transformation)]										[comment OPEN assigns the variable to be a Tranformation/]
[callTransformationsRecursiveTemplate(ps)/]
					[/let]																												[comment CLOSE assigns the variable to be a Tranformation/]
				[elseif (dpd.oclIsKindOf(Library::Job))]																				[comment OPEN checks if the dataProcessingDefinition is a Job/]
					[let libJ : Library::Job = dpd.oclAsType(Library::Job)]																[comment OPEN assigns the variable to be a Job/]
	#--------------------------------------Input data dictionaries--------------------------------------
						[for (arg : Argument | ps._in)]																					[comment OPEN traverse all the input arguments/]
							[if (arg.oclIsKindOf(DataDictionary))]																		[comment OPEN checks if it is a DataDictionary/]
								[let dd_in : DataDictionary = arg.oclAsType(DataDictionary)]											[comment OPEN assigns the variable to be a DataDictionary/]
									[if (aWorkflow.environment.oclIsKindOf(Local))]														[comment OPEN checks if it is a local file and a container/]
	[dd_in.dataDictionaryDefinition.boundTo.name.replaceAll('[(),-/\\s]+', '_')/]='[if (aWorkflow.environment.path.startsWith('.'))][aWorkflow.environment.path.replaceFirst('./', '/')/][else][aWorkflow.environment.path/][/if]/data/[if not ps.oclAsType(DataProcessing).initial_accumulated_processing->isEmpty()][if (ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.trim().indexOf('.')>0)][ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][ps.oclAsType(DataProcessing).initial_accumulated_processing.inputPort->first().fileName.trim()/].parquet[/if][else][if (dd_in.fileName.trim().indexOf('.')>0)][dd_in.fileName.replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_in.fileName.trim()/].parquet[/if][/if]'
									[/if]																								[comment CLOSE checks if it is a local file and a container or a local environment/]
								[/let]																									[comment CLOSE assigns the variable to be a DataDictionary/]
							[/if]																										[comment CLOSE checks if it is a DataDictionary/]
						[/for]																											[comment CLOSE traverse all the input arguments/]
	#--------------------------------------Output data dictionaries--------------------------------------
						[for (arg : Argument | ps.out)]																					[comment OPEN traverse all the output arguments/]
							[if (arg.oclIsKindOf(DataDictionary))]																		[comment OPEN checks if it is a DataDictionary/]
								[let dd_out : DataDictionary = arg.oclAsType(DataDictionary)]											[comment OPEN assigns the variable to be a DataDictionary/]
									[if (aWorkflow.environment.oclIsKindOf(Local))]														[comment OPEN checks if it is a local file and a container/]
	[dd_out.dataDictionaryDefinition.boundTo.name.replaceAll('[(),-/\\s]+', '_')/]='[if (aWorkflow.environment.path.startsWith('.'))][aWorkflow.environment.path.replaceFirst('./', '/')/][else][aWorkflow.environment.path/][/if]/data/[if (dd_out.fileName.trim().indexOf('.')>0)][dd_out.fileName.replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_out.fileName.trim()/].parquet[/if]'
									[/if]																								[comment CLOSE checks if it is a local file and a container or a local environment/]
								[/let]																									[comment CLOSE assigns the variable to be a DataDictionary/]
							[/if]																										[comment CLOSE checks if it is a DataDictionary/]
						[/for]																											[comment CLOSE traverse all the output arguments/]
						[if (ps.oclIsKindOf(DataProcessing))]																			[comment OPEN checks if the actual ProcessingStep is a DataProcessing/]
							[let d : DataProcessing = ps.oclAsType(DataProcessing)]														[comment OPEN assigns the variable to be a DataProcessing/]
								[for (pstep : ProcessingStep | libJ.workflow.dataprocessing)]											[comment OPEN traverse all the dataProcessing/]
									[if (pstep.incoming = null and pstep.outgoing=null)]												[comment OPEN checks if it is isolated/]
										[if (pstep.oclIsKindOf(DataProcessing))]														[comment OPEN checks if the original ProcessingStep is a DataProcessing/]
											[let dp : DataProcessing = pstep.oclAsType(DataProcessing)]									[comment OPEN assigns the variable to be a DataProcessing/]
[generateDataSmells(d)/]

[generateCallTransformation(dp, d)/]
											[/let]																						[comment CLOSE assigns the variable to be a DataProcessing/]
										[/if]																							[comment CLOSE checks if the original ProcessingStep is a DataProcessing/]
										[if (pstep.oclIsKindOf(PMMLModel))]																[comment OPEN checks if the original ProcessingStep is a PMMLModel/]
											[let pmml : PMMLModel = pstep.oclAsType(PMMLModel)]											[comment OPEN assigns the variable to be a PMMLModel/]
	[generatePMML(pmml, ps)/]
											[/let]																						[comment CLOSE assigns the variable to be a PMMLModel/]
										[/if]																							[comment CLOSE checks if the original ProcessingStep is a PMMLModel/]
									[/if]																								[comment CLOSE checks if it is isolated/]
								[/for]																									[comment CLOSE traverse all the dataProcessing/]
								[for (pstep : ProcessingStep | libJ.workflow.dataprocessing)]											[comment OPEN traverse all the dataProcessing/]
									[if (pstep.incoming = null and pstep.outgoing<>null)]												[comment OPEN checks if it is the first dataProcessing/]
[callTransformationsModifiedRecursiveTemplate(pstep, ps)/]
									[/if]																								[comment CLOSE checks if it is the first dataProcessing/]
								[/for]																									[comment CLOSE traverse all the dataProcessing/]
							[/let]																										[comment CLOSE assigns the variable to be a DataProcessing/]
						[/if]																											[comment CLOSE checks if the actual ProcessingStep is a DataProcessing/]
						[if (ps.oclIsKindOf(PMMLModel))]																				[comment OPEN checks if the actual ProcessingStep is a PMMLModel/]
							[for (pstep : ProcessingStep | libJ.workflow.dataprocessing)]												[comment OPEN traverse the dataProcessings in the workflow/]
								[if (pstep.incoming = null and pstep.outgoing<>null)]													[comment OPEN checks if the dataProcessing is isolated/]
[callModifiedRecursiveTemplate(pstep, ps)/]
								[/if]																									[comment CLOSE checks that the dataProcessing is not isolated and is the first/]
							[/for]																										[comment CLOSE traverse the dataProcessings in the workflow/]
						[/if]																											[comment CLOSE checks if the actual ProcessingStep is a PMMLModel/]
					[/let]																												[comment CLOSE assigns the variable to be a Tranformation/]
				[/if]																													[comment CLOSE checks if the dataProcessingDefinition is a Transformation or a Job/]
			[/let]																														[comment CLOSE assigns the variable to be a dataProcessingDefinition/]
		[/if]																															[comment CLOSE checks if the dataProcessingDefinition is a dataProcessingDefinition/]
	[/if]																																[comment CLOSE checks if the DataProcessing is the first (no input link, an output link)/]
[/for]																																	[comment CLOSE traverse all the DataProcessings/]
set_logger("transformations")
generateWorkflow()
[/file]
[/template]


[template public callTransformationsModifiedRecursiveTemplate(pstep : ProcessingStep, ps : ProcessingStep)] [comment]pstep, dw, dataP son el modelo grande. El que tiene todos los dataProcessing con las transformaciones y los contratos[/comment]
	#-----------------New DataProcessing-----------------
[if (pstep.incoming <> null)]																	[comment OPEN checks if there is an incoming link/]
	[if (pstep.incoming.source.dataProcessingDefinition.name<>'split')]							[comment OPEN checks if the operation is split/]
		[for (dd_in : DataDictionary | pstep.inputPort)]										[comment OPEN traverse all the input datasets in the original ProcessingStep/]
	[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet([dd_in.name.replaceAll('[(),-/\\s]+', '_')/])
		[/for]																					[comment CLOSE traverse all the input datasets in the original ProcessingStep/]

	[else]																						[comment OPEN checks that the operation is not split/]
		[for (dc : DataDictionary | pstep.inputPort)]											[comment OPEN read all the input datasets and store them/]
			[for (dc_out : DataDictionary | pstep.incoming.source.outputPort)]					[comment OPEN read the previous DataProcessing output datasets/]
				[if (dc.fileName.trim() = dc_out.fileName)]										[comment OPEN checks that both datasets are the same/]
	[dc.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet([dc.name.replaceAll('[(),-/\\s]+', '_')/])

				[/if]																			[comment CLOSE checks that both datasets are the same/]
			[/for]																				[comment CLOSE read the previous DataProcessing output datasets/]
		[/for]																					[comment CLOSE read all the input datasets and store them/]
	[/if]																						[comment CLOSE checks if the operation is split or not/]
[else]																							[comment OPEN checks if there is not an incoming link/]
	[for (dc : DataDictionary | pstep.inputPort)]												[comment OPEN read all the input datasets and store them/]
	[dc.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet([dc.name.replaceAll('[(),-/\\s]+', '_')/])
	[/for]																						[comment CLOSE read all the input datasets and store them/]
[/if]																							[comment CLOSE checks if there is an incoming link or not/]
[if (pstep.oclIsKindOf(DataProcessing))]														[comment OPEN checks if the original ProcessingStep is a DataProcessing/]
	[let dw : DataProcessing = pstep.oclAsType(DataProcessing)]									[comment OPEN assigns the variable to be a DataProcessing/]
		[if (ps.oclIsKindOf(DataProcessing))]													[comment OPEN checks if the actual ProcessingStep is a DataProcessing/]
			[let d_or : DataProcessing = ps.oclAsType(DataProcessing)]							[comment OPEN assigns the variable to be a DataProcessing/]
	[generateDataSmells(d_or)/]

	[generateCallTransformation(dw, d_or)/]
			[/let]																				[comment CLOSE assigns the variable to be a DataProcessing/]
		[/if]																					[comment CLOSE checks if the actual ProcessingStep is a DataProcessing/]
	[/let]																						[comment CLOSE assigns the variable to be a DataProcessing/]
[elseif (pstep.oclIsKindOf(PMMLModel))]															[comment OPEN checks if the original ProcessingStep is a PMMLModel/]
	[let pmml : PMMLModel = pstep.oclAsType(PMMLModel)]											[comment OPEN assigns the variable to be a PMMLModel/]
	[generatePMML(pmml, ps)/]
	[/let]																						[comment CLOSE assigns the variable to be a PMMLModel/]
[/if]																							[comment CLOSE checks if the original ProcessingStep is a DataProcessing or a PMMLModel/]
[if (pstep.outgoing<>null)]																		[comment OPEN checks if the DataProcessing has an outgoing link (it's not the last)/]
	[let nextPstep : ProcessingStep = pstep.outgoing.target] 									[comment OPEN assigns the next DataProcessing to a variable/]
[callTransformationsModifiedRecursiveTemplate(nextPstep, ps)/]
	[/let]																						[comment OPEN assigns the next DataProcessing to a variable/]
[/if]																							[comment CLOSE checks if the DataProcessing has an outgoing link (it's not the last)/]
[/template]


[template public callTransformationsRecursiveTemplate(ps : ProcessingStep)]
	#-----------------New DataProcessing-----------------
[if (ps.incoming <> null)]																																		[comment OPEN checks if there is an incoming link/]
	[if (ps.incoming.source.dataProcessingDefinition.name<>'split')]																							[comment OPEN checks if the operation is split/]
		[if (ps.eContainer(Workflow).environment.oclIsKindOf(Local))]																							[comment OPEN checks if it is a local file/]
			[for (dd_in : DataDictionary | ps.inputPort)]																										[comment OPEN traverse all the input DataDictionaries in the ProcessingStep/]
	[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet('[if (ps.eContainer(Workflow).environment.path.startsWith('.'))][ps.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][ps.eContainer(Workflow).environment.path/][/if]/data/[if (dd_in.fileName.trim().indexOf('.')>0)][dd_in.fileName.replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_in.fileName/].parquet[/if]')
			[/for]																																				[comment CLOSE traverse all the input DataDictionaries in the ProcessingStep/]
		[/if]																																					[comment CLOSE checks if it is a local file/]

	[else]																																						[comment OPEN checks that the operation is not split/]
		[for (dc : DataDictionary | ps.inputPort)]																												[comment OPEN read all the input datasets and store them/]
			[for (dc_out : DataDictionary | ps.incoming.source.outputPort)]																						[comment OPEN read the previous DataProcessing output datasets/]
				[if (dc.fileName.trim() = dc_out.fileName)]																										[comment OPEN checks that both datasets are the same/]
					[if (ps.eContainer(Workflow).environment.oclIsKindOf(Local))]																				[comment OPEN checks if it is a local file and a container/]
	[dc.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet('[if (ps.eContainer(Workflow).environment.path.startsWith('.'))][ps.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][ps.eContainer(Workflow).environment.path/][/if]/data/[if (dc_out.fileName.trim().indexOf('.')>0)][dc_out.fileName.replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dc_out.fileName/].parquet[/if]')
					[/if]																																		[comment CLOSE checks if it is a local file and a container or a local environment/]
				[/if]																																			[comment CLOSE checks that both datasets are the same/]
			[/for]																																				[comment CLOSE read the previous DataProcessing output datasets/]
		[/for]																																					[comment CLOSE read all the input datasets and store them/]
	[/if]																																						[comment CLOSE checks if the operation is split or not/]
[else]																																							[comment OPEN checks if there is not an incoming link/]
	[for (dc : DataDictionary | ps.inputPort)]																													[comment OPEN read all the input datasets and store them/]
		[if (ps.eContainer(Workflow).environment.oclIsKindOf(Local))]																							[comment OPEN checks if it is a local file and a container/]
	[dc.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet('[if (ps.eContainer(Workflow).environment.path.startsWith('.'))][ps.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][ps.eContainer(Workflow).environment.path/][/if]/data/[if (dc.fileName.trim().indexOf('.')>0)][dc.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dc.fileName.trim()/].parquet[/if]')
		[/if]																																					[comment CLOSE checks if it is a local file and a container or a local environment/]
	[/for]																																						[comment CLOSE read all the input datasets and store them/]
[/if]																																							[comment CLOSE checks if there is an incoming link or not/]
[if (ps.oclIsKindOf(DataProcessing))]																															[comment OPEN checks if the ProcessingStep is a DataProcessing/]
	[let d : DataProcessing = ps.oclAsType(DataProcessing)]																										[comment OPEN assigns the variable to be a DataProcessing/]
	[generateDataSmells(d)/]

	[generateCallTransformation(d, d)/]
	[/let]																																						[comment CLOSE assigns the variable to be a DataProcessing/]
[elseif (ps.oclIsKindOf(PMMLModel))]																															[comment OPEN checks if the ProcessingStep is a PMMLModel/]
	[let pmml : PMMLModel = ps.oclAsType(PMMLModel)]																											[comment OPEN assigns the variable to be a PMMLModel/]
	[generatePMML(pmml, ps)/]
	[/let]																																						[comment CLOSE assigns the variable to be a PMMLModel/]
[/if]																																							[comment CLOSE checks if the ProcessingStep is a DataProcessing or a PMMLModel/]
[if (ps.outgoing<>null)]																																		[comment OPEN checks if the DataProcessing has an outgoing link (it's not the last)/]
	[let nextps : ProcessingStep = ps.outgoing.target]																											[comment OPEN assigns the next DataProcessing to a variable/]
[callTransformationsRecursiveTemplate(nextps)/]
	[/let]																																						[comment OPEN assigns the next DataProcessing to a variable/]
[/if]																																							[comment CLOSE checks if the DataProcessing has an outgoing link (it's not the last)/]
[/template]


[template public generatePMML(pmmlStep : PMMLModel, ps_or : ProcessingStep)] [comment pmmlStep es el workflow con todo el contenido y ps_or es el workflow que solo tiene los dataDictionary/]
[for (dd_instep : DataDictionary | pmmlStep.inputPort)]													[comment OPEN traverse all the input DataDictionaries in the original PMMLModel/]
	[for (dd_inor : DataDictionary | ps_or.inputPort)]													[comment OPEN traverse all the input DataDictionaries in the actual ProcessingStep/]
		[if (dd_instep.dataDictionaryDefinition = dd_inor.dataDictionaryDefinition)]					[comment OPEN checks if the input DataDictionaries in the original PMMLModel and the actual ProcessingStep are the same/]
			[for (dd_outstep : DataDictionary | pmmlStep.outputPort)]									[comment OPEN traverse all the output DataDictionaries in the original PMMLModel/]
				[for (dd_outor : DataDictionary | ps_or.outputPort)]									[comment OPEN traverse all the output DataDictionaries in the actual ProcessingStep/]
					[if (dd_outstep.dataDictionaryDefinition = dd_outor.dataDictionaryDefinition)]		[comment OPEN checks if the output DataDictionaries in the original PMMLModel and the actual ProcessingStep are the same/]
pmml_model = PMMLModel(input_dataset=[dd_instep.name.replaceAll('[(),-/\\s]+', '_')/]_df, output_dataset_fileName="data/[dd_outor.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '')/]", model_learner_pmml_fileName="data/[pmmlStep.filePath.trim().replaceAll('(.*?\\/)', '')/]", export_only_predictions=[if (pmmlStep.onlyPredictions=false)]False[elseif (pmmlStep.onlyPredictions=true)]True[/if], export_test_metrics=[if (pmmlStep.test<>null)]True, train_split=[pmmlStep.test.trainSize/], test_split=[pmmlStep.test.testSize/], export_test_metrics_path='[pmmlStep.test.path/]'[else]False[/if])
						[if (pmmlStep.test<>null)]														[comment OPEN checks if the test class exists/]
pmml_model.train_and_validate_model()
						[/if]																			[comment CLOSE checks if the test class exists/]
					[/if]																				[comment CLOSE checks if the output DataDictionaries in the original PMMLModel and the actual ProcessingStep are the same/]
				[/for]																					[comment CLOSE traverse all the output DataDictionaries in the actual ProcessingStep/]
			[/for]																						[comment CLOSE traverse all the output DataDictionaries in the original PMMLModel/]
		[/if]																							[comment CLOSE checks if the input DataDictionaries in the original PMMLModel and the actual ProcessingStep are the same/]
	[/for]																								[comment CLOSE traverse all the input DataDictionaries in the actual ProcessingStep/]
[/for]																									[comment CLOSE traverse all the input DataDictionaries in the original PMMLModel/]
[/template]


[template public generateCallTransformation(dataProcessing : DataProcessing, dw_modified : DataProcessing)]
[comment]The code below generates the mapping transformations[/comment]
[if (dataProcessing.parameter->notEmpty())]																														[comment OPEN checks that there are parameters in the DataProcessing/]
	[if (dataProcessing.dataProcessingDefinition.name='mapping')]																									[comment OPEN checks that the DataProcessing is a Mapping (FixValue-FixValue)/]
		[for (dd_in : DataDictionary | dataProcessing.inputPort)]																									[comment OPEN traverse all the input DataDictionaries (in theory there is only 1)/]
			[if dd_in.datafield->notEmpty()]																														[comment OPEN checks that there is at least one DataField/]
				[for (df : DataField | dd_in.datafield)]																											[comment OPEN traverse all the DataFields in the input DataDictionary (the same as in the output DataDictionary)/]
input_values_list=['['/][for (aParameter : Parameter | dataProcessing.parameter)  separator(', ')][if (aParameter.oclIsTypeOf(Map))][let map : Map = aParameter.oclAsType(Map)][if (df.dataType=DataType::String or df.dataType=DataType::DateTime or df.dataType=DataType::Time)]'[map.inValue/]'[else][map.inValue/][/if][/let][/if][/for][']'/]
output_values_list=['['/][for (aParameter : Parameter | dataProcessing.parameter)  separator(', ')][if (aParameter.oclIsTypeOf(Map))][let map : Map = aParameter.oclAsType(Map)][if (df.dataType=DataType::String or df.dataType=DataType::DateTime or df.dataType=DataType::Time)]'[map.outvalue/]'[else][map.outvalue/][/if][/let][/if][/for][']'/]
data_type_input_list=['['/][for (aParameter : Parameter | dataProcessing.parameter) separator(', ')][if (aParameter.oclIsTypeOf(Map))][let map : Map = aParameter.oclAsType(Map)][if (df.dataType=DataType::String)]DataType(0)[elseif (df.dataType=DataType::Time)]DataType(1)[elseif (df.dataType=DataType::Integer)]DataType(2)[elseif (df.dataType=DataType::DateTime)]DataType(3)[elseif (df.dataType=DataType::Boolean)]DataType(4)[elseif (df.dataType=DataType::Double)]DataType(5)[elseif (df.dataType=DataType::Float)]DataType(6)[else]None[/if][/let][/if][/for][']'/]
data_type_output_list=['['/][for (aParameter : Parameter | dataProcessing.parameter) separator(', ')][if (aParameter.oclIsTypeOf(Map))][let map : Map = aParameter.oclAsType(Map)][if (df.dataType=DataType::String)]DataType(0)[elseif (df.dataType=DataType::Time)]DataType(1)[elseif (df.dataType=DataType::Integer)]DataType(2)[elseif (df.dataType=DataType::DateTime)]DataType(3)[elseif (df.dataType=DataType::Boolean)]DataType(4)[elseif (df.dataType=DataType::Double)]DataType(5)[elseif (df.dataType=DataType::Float)]DataType(6)[else]None[/if][/let][/if][/for][']'/]
map_operation_list=['['/][for (aParameter : Parameter | dataProcessing.parameter)  separator(', ')][if (aParameter.oclIsTypeOf(Map))][let map : Map = aParameter.oclAsType(Map)][if (map.mapOperation=MapOperation::VALUE_MAPPING)]MapOperation(0)[elseif (map.mapOperation=MapOperation::SUBSTRING)]MapOperation(1)[/if][/let][/if][/for][']'/]
					[if (df.oclIsTypeOf(Continuous) and df.oclAsType(Continuous).numDecimals <> null)]
					[/if]
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=data_transformations.transform_fix_value_fix_value(data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df, input_values_list=input_values_list,
															  output_values_list=output_values_list,
						                                      data_type_input_list = data_type_input_list,
						                                      data_type_output_list = data_type_output_list,
															  map_operation_list = map_operation_list,
															  field_in = '[df.displayName/]', field_out = '[df.out.displayName/]')

					[if (dw_modified.dataProcessingDefinition.oclIsKindOf(Library::DataProcessingDefinition))]														[comment OPEN checks if the DataProcessing contains a DataProcessingDefinition/]
						[let dpd : Library::DataProcessingDefinition = dw_modified.dataProcessingDefinition.oclAsType(Library::DataProcessingDefinition)]			[comment OPEN assigns the variable to be a DataProcessingDefinition/]
							[if (dpd.oclIsKindOf(Library::Transformation))]																							[comment OPEN checks if the DataProcessingDefinition is a Transformation/]
								[let libT : Library::Transformation = dpd.oclAsType(Library::Transformation)]														[comment OPEN assigns the variable to be a Transformation/]
									[if (dataProcessing.eContainer(Workflow).environment.oclIsKindOf(Local))]														[comment OPEN checks if the Environment is local/]
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df.to_parquet('[if (dataProcessing.eContainer(Workflow).environment.path.startsWith('.'))][dataProcessing.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][dataProcessing.eContainer(Workflow).environment.path/][/if]/data/[if (dd_in.out.fileName.trim().indexOf('.')>0)][dd_in.out.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_in.out.fileName.trim()/].parquet[/if]')
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet('[if (dataProcessing.eContainer(Workflow).environment.path.startsWith('.'))][dataProcessing.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][dataProcessing.eContainer(Workflow).environment.path/][/if]/data/[if (dd_in.out.fileName.trim().indexOf('.')>0)][dd_in.out.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_in.out.fileName.trim()/].parquet[/if]')
									[/if]																															[comment CLOSE checks if the Environment is local/]
								[/let]																																[comment CLOSE assigns the variable to be a Transformation/]
							[elseif (dpd.oclIsKindOf(Library::Job))]																								[comment OPEN checks if the DataProcessingDefinition is a Job/]
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df.to_parquet([dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/])	
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet([dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/])
							[/if]																																	[comment CLOSE checks if the DataProcessingDefinition is a Transformation or a Job/]
						[/let]																																		[comment CLOSE assigns the variable to be a DataProcessingDefinition/]
					[/if]																																			[comment CLOSE checks if the DataProcessing contains a DataProcessingDefinition/]
				[/for]																																				[comment CLOSE traverse all the DataFields in the input DataDictionary (the same as in the output DataDictionary)/]
			[else]																																					[comment OPEN checks that there are no DataField/]
input_values_list=['['/][for (aParameter : Parameter | dataProcessing.parameter)  separator(', ')][if (aParameter.oclIsTypeOf(Map))][let map : Map = aParameter.oclAsType(Map)]'[map.inValue/]'[/let][/if][/for][']'/]
output_values_list=['['/][for (aParameter : Parameter | dataProcessing.parameter)  separator(', ')][if (aParameter.oclIsTypeOf(Map))][let map : Map = aParameter.oclAsType(Map)]'[map.outvalue/]'[/let][/if][/for][']'/]

[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=data_transformations.transform_fix_value_fix_value(data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df, input_values_list=input_values_list,
															  output_values_list=output_values_list,
						                                      data_type_input_list = None,
						                                      data_type_output_list = None, field_in = None, filed_out = None)
				[if (dw_modified.dataProcessingDefinition.oclIsKindOf(Library::DataProcessingDefinition))]															[comment OPEN checks if the DataProcessing contains a DataProcessingDefinition/]
					[let dpd : Library::DataProcessingDefinition = dw_modified.dataProcessingDefinition.oclAsType(Library::DataProcessingDefinition)]				[comment OPEN assigns the variable to be a DataProcessingDefinition/]
						[if (dpd.oclIsKindOf(Library::Transformation))]																								[comment OPEN checks if the DataProcessingDefinition is a Transformation/]
								[let libT : Library::Transformation = dpd.oclAsType(Library::Transformation)]														[comment OPEN assigns the variable to be a Transformation/]
									[if (dataProcessing.eContainer(Workflow).environment.oclIsKindOf(Local))]														[comment OPEN checks if the Environment is local/]
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df.to_parquet('[if (dataProcessing.eContainer(Workflow).environment.path.startsWith('.'))][dataProcessing.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][dataProcessing.eContainer(Workflow).environment.path/][/if]/data/[if (dd_in.out.fileName.trim().indexOf('.')>0)][dd_in.out.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_in.out.fileName.trim()/].parquet[/if]')
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet('[if (dataProcessing.eContainer(Workflow).environment.path.startsWith('.'))][dataProcessing.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][dataProcessing.eContainer(Workflow).environment.path/][/if]/data/[if (dd_in.out.fileName.trim().indexOf('.')>0)][dd_in.out.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_in.out.fileName.trim()/].parquet[/if]')
									[/if]																															[comment CLOSE checks if the Environment is local/]
								[/let]																																[comment CLOSE assigns the variable to be a Transformation/]
						[elseif (dpd.oclIsKindOf(Library::Job))]																									[comment OPEN checks if the DataProcessingDefinition is a Job/]
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df.to_parquet([dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/])	
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet([dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/])
						[/if]																																		[comment CLOSE checks if the DataProcessingDefinition is a Transformation or a Job/]
					[/let]																																			[comment CLOSE assigns the variable to be a DataProcessingDefinition/]
				[/if]																																				[comment CLOSE checks if the DataProcessing contains a DataProcessingDefinition/]			
			[/if]																																					[comment CLOSE checks that there are DataFields or not/]
		[/for]																																						[comment CLOSE traverse all the input DataDictionaries (in theory there is only 1)/]
	[/if]																																							[comment CLOSE checks that the DataProcessing is a Mapping (FixValue-FixValue)/]
[comment]The code below generates the transformations different from mapping for every field[/comment]
	[if (dataProcessing.dataProcessingDefinition.name<>'mapping')]																									[comment OPEN checks that the DataProcessing is not a Mapping/]
		[for (dd_in : DataDictionary | dataProcessing.inputPort)]																										[comment OPEN traverse all the input DataDictionaries/]
[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed=[if not dataProcessing.oclAsType(DataProcessing).initial_accumulated_processing->isEmpty()]pd.read_parquet('[if (dataProcessing.eContainer(Workflow).environment.path.startsWith('.'))][dataProcessing.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][dataProcessing.eContainer(Workflow).environment.path/][/if]/data/[if (dataProcessing.oclAsType(DataProcessing).initial_accumulated_processing.outputPort->first().fileName.trim().indexOf('.')>0)][dataProcessing.oclAsType(DataProcessing).initial_accumulated_processing.outputPort->first().fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dataProcessing.oclAsType(DataProcessing).initial_accumulated_processing.outputPort->first().fileName.trim()/].parquet[/if]')[else][dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df.copy()[/if]
		[/for]																																							[comment CLOSE traverse all the input DataDictionaries/]
		[for (p : Parameter | dataProcessing.parameter)]																												[comment OPEN traverse all the parameters in the DataProcessing/]
			[if (p.oclIsKindOf(DerivedField))]																															[comment OPEN checks that the parameter is a DerivedField/]
				[let derf : DerivedField = p.oclAsType(DerivedField)]																									[comment OPEN assigns the parameter to be a DerivedField/]
					[for (dd_in : DataDictionary | dataProcessing.inputPort)]																							[comment OPEN traverse al the input DataDictionaries/]
[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed=data_transformations.transform_derived_field(data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed,
															  data_type_output = [if (derf.der_dataField.dataType=DataType::String)]DataType(0)[elseif (derf.der_dataField.dataType=DataType::Time)]DataType(1)[elseif (derf.der_dataField.dataType=DataType::Integer)]DataType(2)[elseif (derf.der_dataField.dataType=DataType::DateTime)]DataType(3)[elseif (derf.der_dataField.dataType=DataType::Boolean)]DataType(4)[elseif (derf.der_dataField.dataType=DataType::Double)]DataType(5)[elseif (derf.der_dataField.dataType=DataType::Float)]DataType(6)[else]None[/if],
															  field_in = '[derf.der_dataField._in->first().displayName/]', field_out = '[derf.der_dataField.displayName/]')

[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed
						[if (dw_modified.dataProcessingDefinition.oclIsKindOf(Library::DataProcessingDefinition))]														[comment OPEN checks if the DataProcessing contains a DataProcessingDefinition/]
							[let dpd : Library::DataProcessingDefinition = dw_modified.dataProcessingDefinition.oclAsType(Library::DataProcessingDefinition)]			[comment OPEN assigns the variable to be a DataProcessingDefinition/]
								[if (dpd.oclIsKindOf(Library::Transformation))]																							[comment OPEN checks if the DataProcessingDefinition is a Transformation/]
									[let libT : Library::Transformation = dpd.oclAsType(Library::Transformation)]														[comment OPEN assigns the variable to be a Transformation/]
										[if (dataProcessing.eContainer(Workflow).environment.oclIsKindOf(Local))]														[comment OPEN checks if the Environment is Local/]
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df.to_parquet('[if (dataProcessing.eContainer(Workflow).environment.path.startsWith('.'))][dataProcessing.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][dataProcessing.eContainer(Workflow).environment.path/][/if]/data/[if (dd_in.out.fileName.trim().indexOf('.')>0)][dd_in.out.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_in.out.fileName.trim()/].parquet[/if]')
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet('[if (dataProcessing.eContainer(Workflow).environment.path.startsWith('.'))][dataProcessing.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][dataProcessing.eContainer(Workflow).environment.path/][/if]/data/[if (dd_in.out.fileName.trim().indexOf('.')>0)][dd_in.out.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_in.out.fileName.trim()/].parquet[/if]')
										[/if]																															[comment CLOSE checks if the Environment is Local/]
									[/let]																																[comment CLOSE assigns the variable to be a Transformation/]
								[elseif (dpd.oclIsKindOf(Library::Job))]																								[comment OPEN checks if the DataProcessingDefinition is a Job/]
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df.to_parquet([dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/])	
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet([dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/])
								[/if]																																	[comment CLOSE checks if the DataProcessingDefinition is a Transformation or a Job/]
							[/let]																																		[comment CLOSE assigns the variable to be a DataProcessingDefinition/]
						[/if]																																			[comment CLOSE checks if the DataProcessing contains a DataProcessingDefinition/]
					[/for]																																				[comment CLOSE traverse all the input DataDictionaries/]
				[/let]																																					[comment CLOSE assigns the parameter to be a DerivedField/]
			[/if]																																						[comment CLOSE checks that the parameter is a DerivedField/]
		    [if (p.oclIsKindOf(ImputeType))]																															[comment OPEN checks that the parameter is an ImputeType/]
		        [let imType : ImputeType = p.oclAsType(ImputeType)]																										[comment OPEN assigns the parameter to be an ImputeType/]
					[for (dd_in : DataDictionary | dataProcessing.inputPort)]																							[comment OPEN traverse all the input DataDictionaries (in theory there is only 1)/]
						[if dd_in.datafield->notEmpty()]																												[comment OPEN checks that there is at least DataField/]
							[for (df : DataField | dd_in.datafield)]																									[comment OPEN traverse all the DataFields in the input DataDictionary (the same as in the output DataDictionary)/]
missing_values_list=['['/][for (mv : ValueField | df.missingValues) separator(', ')][if (df.dataType=DataType::String or df.dataType=DataType::DateTime or df.dataType=DataType::Time)]'[mv.value/]'[else][mv.value/][/if][/for][']'/]
								[if (df.oclIsTypeOf(Continuous) and df.oclAsType(Continuous).numDecimals <> null)]
								[/if]
								[if (dataProcessing.dataProcessingDefinition.name='imputeByFixValue')]																	[comment OPEN checks that the DataProcessing is an imputeByFixValue(SpecialValue_FixValue)/]
					            	[if (imType.oclIsKindOf(FixValue))]																									[comment OPEN checks that the ImputeType is a FixValue/]
		        	    				[let fv : FixValue = imType.oclAsType(FixValue)]																				[comment OPEN assigns the ImputeType as a FixValue/]
[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed=data_transformations.transform_special_value_fix_value(data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed,
															  special_type_input=SpecialType([if (fv.imputeValue=SpecialValue::Missing)]0[elseif (fv.imputeValue=SpecialValue::Invalid)]1[elseif (fv.imputeValue=SpecialValue::Outlier)]2[/if]), fix_value_output=[if (df.dataType=DataType::String or df.dataType=DataType::DateTime or df.dataType=DataType::Time)]'[fv.value.value/]'[else][fv.value.value/][/if],
															  missing_values=missing_values_list,		
						                                      data_type_output = [if (df.dataType=DataType::String)]DataType(0)[elseif (df.dataType=DataType::Time)]DataType(1)[elseif (df.dataType=DataType::Integer)]DataType(2)[elseif (df.dataType=DataType::DateTime)]DataType(3)[elseif (df.dataType=DataType::Boolean)]DataType(4)[elseif (df.dataType=DataType::Double)]DataType(5)[elseif (df.dataType=DataType::Float)]DataType(6)[else]None[/if],
															  axis_param=0, field_in = '[df.displayName/]', field_out = '[df.out.displayName/]')

				                		[/let]																															[comment CLOSE assigns the ImputeType as a FixValue/]
				            		[/if]																																[comment CLOSE checks that the ImputeType is a FixValue/]
								[/if]																																	[comment CLOSE checks that the DataProcessing is an imputeByFixValue(SpecialValue_FixValue)/]
								[if (dataProcessing.dataProcessingDefinition.name='imputeByDerivedValue')]																[comment OPEN checks that the DataProcessing is an imputeByDerivedValue(SpecialValue_DerivedValue)/]
		        					[if (imType.oclIsKindOf(DerivedValue))]																								[comment OPEN checks that the ImputeType is a DerivedValue/]
		            					[let dv : DerivedValue = imType.oclAsType(DerivedValue)]																		[comment OPEN assigns the ImputeType as a DerivedValue/]
[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed=data_transformations.transform_special_value_derived_value(data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed,
															  special_type_input=SpecialType([if (dv.imputeValue=SpecialValue::Missing)]0[elseif (dv.imputeValue=SpecialValue::Invalid)]1[elseif (dv.imputeValue=SpecialValue::Outlier)]2[/if]), derived_type_output=DerivedType([if (dv.type=DerivedType::MostFrequent)]0[elseif (dv.type=DerivedType::Previous)]1[elseif (dv.type=DerivedType::Next)]2[/if]),
															  missing_values=missing_values_list,		
															  axis_param=0, field_in = '[df.displayName/]', field_out = '[df.out.displayName/]')

				                		[/let]																															[comment CLOSE assigns the ImputeType as a DerivedValue/]
				            		[/if]																																[comment CLOSE checks that the ImputeType is a DerivedValue/]
								[/if]																																	[comment CLOSE checks that the DataProcessing is an imputeByDerivedValue(SpecialValue_DerivedValue)/]
								[if (dataProcessing.dataProcessingDefinition.name='imputeByNumericOp')]																	[comment OPEN checks that the DataProcessing is an imputeByNumericOp(SpecialValue_NumOp)/]
		        					[if (imType.oclIsKindOf(NumOp))]																									[comment OPEN checks that the ImputeType is a NumOp/]
		            					[let nop : NumOp = imType.oclAsType(NumOp)]																						[comment OPEN assigns the ImputeType as a NumOp/]
[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed=data_transformations.transform_special_value_num_op(data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed,
															  special_type_input=SpecialType([if (nop.imputeValue=SpecialValue::Missing)]0[elseif (nop.imputeValue=SpecialValue::Invalid)]1[elseif (nop.imputeValue=SpecialValue::Outlier)]2[/if]), num_op_output=Operation([if (nop.operation=Operation::Interpolation)]0[elseif (nop.operation=Operation::Mean)]1[elseif (nop.operation=Operation::Median)]2[elseif (nop.operation=Operation::Closest)]3[/if]),
															  missing_values=missing_values_list,		
															  axis_param=0, field_in = '[df.displayName/]', field_out = '[df.out.displayName/]')

					                	[/let]																															[comment CLOSE assigns the ImputeType as a NumOp/]
					            	[/if]																																[comment CLOSE checks that the ImputeType is a NumOp/]
								[/if]																																	[comment CLOSE checks that the DataProcessing is an imputeByNumericOp(SpecialValue_NumOp)/]
							[/for]																																		[comment CLOSE traverse all the DataFields in the input DataDictionary (the same as in the output DataDictionary)/]
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed
							[if (dw_modified.dataProcessingDefinition.oclIsKindOf(Library::DataProcessingDefinition))]													[comment OPEN checks if the DataProcessing contains a DataProcessingDefinition/]
								[let dpd : Library::DataProcessingDefinition = dw_modified.dataProcessingDefinition.oclAsType(Library::DataProcessingDefinition)]		[comment OPEN assigns the variable to be a DataProcessingDefinition/]
									[if (dpd.oclIsKindOf(Library::Transformation))]																						[comment OPEN checks if the DataProcessingDefinition is a Transformation/]
										[let libT : Library::Transformation = dpd.oclAsType(Library::Transformation)]													[comment OPEN assigns the variable to be a Transformation/]
											[if (dataProcessing.eContainer(Workflow).environment.oclIsKindOf(Local))]													[comment OPEN checks if the Environment is Local/]
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df.to_parquet('[if (dataProcessing.eContainer(Workflow).environment.path.startsWith('.'))][dataProcessing.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][dataProcessing.eContainer(Workflow).environment.path/][/if]/data/[if (dd_in.out.fileName.trim().indexOf('.')>0)][dd_in.out.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_in.out.fileName.trim()/].parquet[/if]')
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet('[if (dataProcessing.eContainer(Workflow).environment.path.startsWith('.'))][dataProcessing.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][dataProcessing.eContainer(Workflow).environment.path/][/if]/data/[if (dd_in.out.fileName.trim().indexOf('.')>0)][dd_in.out.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_in.out.fileName.trim()/].parquet[/if]')
											[/if]																														[comment CLOSE checks if the Environment is Local/]
										[/let]																															[comment CLOSE assigns the variable to be a Transformation/]
									[elseif (dpd.oclIsKindOf(Library::Job))]																							[comment OPEN checks if the DataProcessingDefinition is a Job/]
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df.to_parquet([dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/])	
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet([dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/])
									[/if]																																[comment CLOSE checks if the DataProcessingDefinition is a Transformation or a Job/]
								[/let]																																	[comment CLOSE assigns the variable to be a DataProcessingDefinition/]
							[/if]																																		[comment CLOSE checks if the DataProcessing contains a DataProcessingDefinition/]
[comment]The code below generates the same transformation generated above but for the whole dataframe instead of a field[/comment]
						[else]																																			[comment OPEN checks that there are no DataFields/]
							[if (dataProcessing.dataProcessingDefinition.name='imputeByFixValue')]																		[comment OPEN checks that the DataProcessing is an imputeByFixValue(SpecialValue_FixValue)/]
								[if (imType.oclIsKindOf(FixValue))]																										[comment OPEN checks that the ImputeType is a FixValue/]
				            		[let fv : FixValue = imType.oclAsType(FixValue)]																						[comment OPEN assigns the ImputeType as a FixValue/]
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=data_transformations.transform_special_value_fix_value(data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df,
															  special_type_input=SpecialType([if (imType.imputeValue=SpecialValue::Missing)]0[elseif (imType.imputeValue=SpecialValue::Invalid)]1[elseif (imType.imputeValue=SpecialValue::Outlier)]2[/if]), fix_value_output='[fv.value.value/]', missing_values=None
						                                      data_type_output = None, axis_param=0, field_in = None, field_out = None)		

				            		[/let]																																[comment CLOSE assigns the ImputeType as a FixValue/]
				        		[/if]																																	[comment CLOSE checks that the ImputeType is a FixValue/]
							[/if]																																		[comment CLOSE checks that the DataProcessing is an imputeByFixValue(SpecialValue_FixValue)/]
							[if (dataProcessing.dataProcessingDefinition.name='imputeByDerivedValue')]																	[comment OPEN checks that the DataProcessing is an imputeByDerivedValue(SpecialValue_DerivedValue)/]	
		        				[if (imType.oclIsKindOf(DerivedValue))]																									[comment OPEN checks that the ImputeType is a DerivedValue/]
		            				[let dv : DerivedValue = imType.oclAsType(DerivedValue)]																			[comment OPEN assigns the ImputeType as a DerivedValue/]
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=data_transformations.transform_special_value_derived_value(data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df,
															  special_type_input=SpecialType([if (dv.imputeValue=SpecialValue::Missing)]0[elseif (dv.imputeValue=SpecialValue::Invalid)]1[elseif (dv.imputeValue=SpecialValue::Outlier)]2[/if]), derived_type_output=DerivedType([if (dv.type=DerivedType::MostFrequent)]0[elseif (dv.type=DerivedType::Previous)]1[elseif (dv.type=DerivedType::Next)]2[/if]),
															  missing_values=None, axis_param=0, field_in = None, field_out = None)		

					            	[/let]																																[comment CLOSE assigns the ImputeType as a DerivedValue/]
					        	[/if]																																	[comment CLOSE checks that the ImputeType is a DerivedValue/]
							[/if]																																		[comment CLOSE checks that the DataProcessing is an imputeByDerivedValue(SpecialValue_DerivedValue)/]
							[if (dataProcessing.dataProcessingDefinition.name='imputeByNumericOp')]																		[comment OPEN checks that the DataProcessing is an imputeByNumericOp(SpecialValue_NumOp)/]
		    					[if (imType.oclIsKindOf(NumOp))]																										[comment OPEN checks that the ImputeType is a NumOp/]
		            				[let nop : NumOp = imType.oclAsType(NumOp)]																							[comment OPEN assigns the ImputeType as a NumOp/]
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=data_transformations.transform_special_value_num_op(data_dictionary=[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df,
															  special_type_input=SpecialType([if (nop.imputeValue=SpecialValue::Missing)]0[elseif (nop.imputeValue=SpecialValue::Invalid)]1[elseif (nop.imputeValue=SpecialValue::Outlier)]2[/if]), num_op_output=Operation([if (nop.operation=Operation::Interpolation)]0[elseif (nop.operation=Operation::Mean)]1[elseif (nop.operation=Operation::Median)]2[elseif (nop.operation=Operation::Closest)]3[/if]),
															  missing_values=None, axis_param=0, field_in = None, field_out = None)		

					            	[/let]																																[comment CLOSE assigns the ImputeType as a NumOp/]
					        	[/if]																																	[comment CLOSE checks that the ImputeType is a NumOp/]
							[/if]																																		[comment CLOSE checks that the DataProcessing is an imputeByNumericOp(SpecialValue_NumOp)/]
							[if (dw_modified.dataProcessingDefinition.oclIsKindOf(Library::DataProcessingDefinition))]													[comment OPEN checks if the DataProcessing contains a DataProcessingDefinition/]
								[let dpd : Library::DataProcessingDefinition = dw_modified.dataProcessingDefinition.oclAsType(Library::DataProcessingDefinition)]		[comment OPEN assigns the variable to be a DataProcessingDefinition/]
									[if (dpd.oclIsKindOf(Library::Transformation))]																						[comment OPEN checks if the DataProcessingDefinition is a Transformation/]
										[let libT : Library::Transformation = dpd.oclAsType(Library::Transformation)]													[comment OPEN assigns the variable to be a Transformation/]
											[if (dataProcessing.eContainer(Workflow).environment.oclIsKindOf(Local))]													[comment OPEN checks if the Environment is Local/]
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df.to_parquet('[if (dataProcessing.eContainer(Workflow).environment.path.startsWith('.'))][dataProcessing.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][dataProcessing.eContainer(Workflow).environment.path/][/if]/data/[if (dd_in.out.fileName.trim().indexOf('.')>0)][dd_in.out.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_in.out.fileName.trim()/].parquet[/if]')
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet('[if (dataProcessing.eContainer(Workflow).environment.path.startsWith('.'))][dataProcessing.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][dataProcessing.eContainer(Workflow).environment.path/][/if]/data/[if (dd_in.out.fileName.trim().indexOf('.')>0)][dd_in.out.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_in.out.fileName.trim()/].parquet[/if]')
											[/if]																														[comment CLOSE checks if the Environment is Local/]
										[/let]																															[comment CLOSE assigns the variable to be a Transformation/]
									[elseif (dpd.oclIsKindOf(Library::Job))]																							[comment OPEN checks if the DataProcessingDefinition is a Job/]
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df.to_parquet([dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/])	
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet([dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/])
									[/if]																																[comment CLOSE checks if the DataProcessingDefinition is a Transformation or a Job/]
								[/let]																																	[comment CLOSE assigns the variable to be a DataProcessingDefinition/]
							[/if]																																		[comment CLOSE checks if the DataProcessing contains a DataProcessingDefinition/]
						[/if]																																			[comment CLOSE checks if there are DataFields or not/]
					[/for]																																				[comment CLOSE traverse all the input DataDictionaries (in theory there is only 1)/]
				[/let]																																					[comment CLOSE assigns the parameter to be an ImputeType/]
			[/if]																																						[comment CLOSE checks that the parameter is an ImputeType/]
			[if (dataProcessing.dataProcessingDefinition.name='binner')]																								[comment OPEN checks that the DataProcessing is a Binner (interval_FixValue)/]
				[if (p.oclIsKindOf(DiscretizeBin))]																														[comment OPEN checks that the parameter is an DiscretizeBin/]
					[let binner : DiscretizeBin = p.oclAsType(DiscretizeBin)]																							[comment OPEN assigns the parameter to be a DiscretizeBin/]
						[for (dd_in : DataDictionary | dataProcessing.inputPort)]																						[comment OPEN traverse all the input DataDictionaries (in theory there is only 1)/]
							[if dd_in.datafield->notEmpty()]																											[comment OPEN checks that there is at least DataField/]
								[for (df : DataField | dd_in.datafield)]																								[comment OPEN traverse all the DataFields in the input DataDictionary/]
									[if (df.oclIsTypeOf(Continuous) and df.oclAsType(Continuous).numDecimals <> null)]
									[/if]
									[for (interval : Interval | binner.interval)]																						[comment OPEN traverse all the intervals in the binner/]
[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed=data_transformations.transform_interval_fix_value(data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed,
															  left_margin=[interval.leftMargin/], right_margin=[interval.rightMargin/],
															  closure_type=Closure([if (interval.clousure=ClosureType::openOpen)]0[elseif(interval.clousure=ClosureType::openClosed)]1[elseif(interval.clousure=ClosureType::closedOpen)]2[elseif(interval.clousure=ClosureType::closedClosed)]3[/if]),
															  fix_value_output=[if (df.out.dataType=DataType::String or df.out.dataType=DataType::DateTime or df.out.dataType=DataType::Time)]'[binner.binValue/]'[else][binner.binValue/][/if],
						                                      data_type_output = [if (df.out.dataType=DataType::String)]DataType(0)[elseif (df.out.dataType=DataType::Time)]DataType(1)[elseif (df.out.dataType=DataType::Integer)]DataType(2)[elseif (df.out.dataType=DataType::DateTime)]DataType(3)[elseif (df.out.dataType=DataType::Boolean)]DataType(4)[elseif (df.out.dataType=DataType::Double)]DataType(5)[elseif (df.out.dataType=DataType::Float)]DataType(6)[else]None[/if],
															  field_in = '[df.displayName/]',
															  field_out = '[df.out.displayName/]')

									[/for]																																[comment CLOSE traverse all the intervals in the binner/]
								[/for]																																	[comment CLOSE traverse all the DataFields in the input DataDictionary/]
							[else]																																		[comment OPEN checks that there are not DataFields/]
								[for (interval : Interval | binner.interval)]																							[comment OPEN traverse all the intervals in the binner/]
[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed=data_transformations.transform_interval_fix_value(data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed,
														  left_margin=[interval.leftMargin/], right_margin=[interval.rightMargin/],
														  closure_type=Closure([if (interval.clousure=ClosureType::openOpen)]0[elseif(interval.clousure=ClosureType::openClosed)]1[elseif(interval.clousure=ClosureType::closedOpen)]2[elseif(interval.clousure=ClosureType::closedClosed)]3[/if]),
														  fix_value_output='[binner.binValue/]', data_type_output = None, field_in = None, field_out = None)

								[/for]																																	[comment CLOSE traverse all the intervals in the binner/]
							[/if]																																		[comment CLOSE checks if there are DataFields/]
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed
							[if (dw_modified.dataProcessingDefinition.oclIsKindOf(Library::DataProcessingDefinition))]													[comment OPEN checks if the DataProcessing contains a DataProcessingDefinition/]
								[let dpd : Library::DataProcessingDefinition = dw_modified.dataProcessingDefinition.oclAsType(Library::DataProcessingDefinition)]		[comment OPEN assigns the variable to be a DataProcessingDefinition/]
									[if (dpd.oclIsKindOf(Library::Transformation))]																						[comment OPEN checks if the DataProcessingDefinition is a Transformation/]
										[let libT : Library::Transformation = dpd.oclAsType(Library::Transformation)]													[comment OPEN assigns the variable to be a Transformation/]
											[if (dataProcessing.eContainer(Workflow).environment.oclIsKindOf(Local))]													[comment OPEN checks if the Environment is Local/]
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df.to_parquet('[if (dataProcessing.eContainer(Workflow).environment.path.startsWith('.'))][dataProcessing.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][dataProcessing.eContainer(Workflow).environment.path/][/if]/data/[if (dd_in.out.fileName.trim().indexOf('.')>0)][dd_in.out.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_in.out.fileName.trim()/].parquet[/if]')
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet('[if (dataProcessing.eContainer(Workflow).environment.path.startsWith('.'))][dataProcessing.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][dataProcessing.eContainer(Workflow).environment.path/][/if]/data/[if (dd_in.out.fileName.trim().indexOf('.')>0)][dd_in.out.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_in.out.fileName.trim()/].parquet[/if]')
											[/if]																														[comment CLOSE checks if the Environment is Local/]
										[/let]																															[comment CLOSE assigns the variable to be a Transformation/]
									[elseif (dpd.oclIsKindOf(Library::Job))]																							[comment OPEN checks if the DataProcessingDefinition is a Job/]
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df.to_parquet([dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/])
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet([dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/])
									[/if]																																[comment CLOSE checks if the DataProcessingDefinition is a Transformation or a Job/]
								[/let]																																	[comment CLOSE assigns the variable to be a DataProcessingDefinition/]
							[/if]																																		[comment CLOSE checks if the DataProcessing contains a DataProcessingDefinition/]
						[/for]																																			[comment CLOSE traverse all the intervals in the binner/]
					[/let]																																				[comment OPEN assigns the parameter to be an DiscretizeBin/]
				[/if]																																					[comment CLOSE checks that the parameter is an DiscretizeBin/]
			[/if]																																						[comment CLOSE checks that the DataProcessing is a Binner (interval_FixValue)/]
			[if (dataProcessing.dataProcessingDefinition.name='categoricalToContinuous')]																				[comment OPEN checks that the DataProcessing is categoricalToContinuous(StringToNumber)/]
				[if (p.oclIsKindOf(CastType))]																															[comment OPEN checks that the parameter is a CastType/]
					[let cast : CastType = p.oclAsType(CastType)]																										[comment OPEN assigns the variable to be a CastType/]
						[for (dd_in : DataDictionary | dataProcessing.inputPort)]																						[comment OPEN traverse the input DataDictionaries/]
							[for (df : DataField | dd_in.datafield)]																									[comment OPEN traverse the DataFields/]
								[if (df.oclIsTypeOf(Continuous) and df.oclAsType(Continuous).numDecimals <> null)]
								[/if]
[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed=data_transformations.transform_cast_type(data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed,
																data_type_output= [if (cast.type=DataType::String)]DataType(0)[elseif (cast.type=DataType::Time)]DataType(1)[elseif (cast.type=DataType::Integer)]DataType(2)[elseif (cast.type=DataType::DateTime)]DataType(3)[elseif (cast.type=DataType::Boolean)]DataType(4)[elseif (cast.type=DataType::Double)]DataType(5)[elseif (cast.type=DataType::Float)]DataType(6)[else]None[/if],
																field='[df.displayName/]', origin_function="[dataProcessing.origin_function/]")

							[/for]																																		[comment CLOSE traverse the DataFields/]
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed
							[if (dw_modified.dataProcessingDefinition.oclIsKindOf(Library::DataProcessingDefinition))]													[comment OPEN checks if the DataProcessing contains a DataProcessingDefinition/]
								[let dpd : Library::DataProcessingDefinition = dw_modified.dataProcessingDefinition.oclAsType(Library::DataProcessingDefinition)]		[comment OPEN assigns the variable to be a DataProcessingDefinition/]
									[if (dpd.oclIsKindOf(Library::Transformation))]																						[comment OPEN checks if the DataProcessingDefinition is a Transformation/]
										[let libT : Library::Transformation = dpd.oclAsType(Library::Transformation)]													[comment OPEN assigns the variable to be a Transformation/]
											[if (dataProcessing.eContainer(Workflow).environment.oclIsKindOf(Local))]													[comment OPEN checks if the Environment is Local/]
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df.to_parquet('[if (dataProcessing.eContainer(Workflow).environment.path.startsWith('.'))][dataProcessing.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][dataProcessing.eContainer(Workflow).environment.path/][/if]/data/[if (dd_in.out.fileName.trim().indexOf('.')>0)][dd_in.out.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_in.out.fileName.trim()/].parquet[/if]')
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet('[if (dataProcessing.eContainer(Workflow).environment.path.startsWith('.'))][dataProcessing.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][dataProcessing.eContainer(Workflow).environment.path/][/if]/data/[if (dd_in.out.fileName.trim().indexOf('.')>0)][dd_in.out.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_in.out.fileName.trim()/].parquet[/if]')
											[/if]																														[comment CLOSE checks if the Environment is Local/]
										[/let]																															[comment CLOSE assigns the variable to be a Transformation/]
									[elseif (dpd.oclIsKindOf(Library::Job))]																							[comment OPEN checks if the DataProcessingDefinition is a Job/]
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df.to_parquet([dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/])	
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet([dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/])
									[/if]																																[comment CLOSE checks if the DataProcessingDefinition is a Transformation or a Job/]
								[/let]																																	[comment CLOSE assigns the variable to be a DataProcessingDefinition/]
							[/if]																																		[comment CLOSE checks if the DataProcessing contains a DataProcessingDefinition/]
						[/for]																																			[comment CLOSE traverse the input DataDictionaries/]
					[/let]																																				[comment CLOSE assigns the variable to be a CastType/]
				[/if]																																					[comment CLOSE checks that the parameter is a CastType/]
			[/if]																																						[comment CLOSE checks that the DataProcessing is categoricalToContinuous(StringToNumber)/]
			[if (dataProcessing.dataProcessingDefinition.name='rowFilterPrimitive' or dataProcessing.dataProcessingDefinition.name='rowFilterRange' or dataProcessing.dataProcessingDefinition.name='rowFilterMissing')]							[comment OPEN checks that the DataProcessing is rowFilter/]
				[if (p.oclIsKindOf(FilterValue))]																														[comment OPEN checks that the parameter is a FilterValue/]
					[for (dd_in : DataDictionary | dataProcessing.inputPort)]
						[let fValue : FilterValue = p.oclAsType(FilterValue)]																							[comment OPEN assigns the variable to be a FilterValue/]
columns_[fValue.filterValueDef.name/]=['['/][for (df : DataField | dd_in.datafield) separator (', ')]'[df.displayName/]'[/for][']'/]
						[for (df : DataField | dd_in.datafield)]
							[if (df.oclIsTypeOf(Continuous) and df.oclAsType(Continuous).numDecimals <> null)]
							[/if]
						[/for]
							[if (not fValue.primitive->isEmpty())]																										[comment OPEN checks that the list of primitives is not empty/]
filter_fix_value_list_[fValue.filterValueDef.name/]=['['/][for (prim : Primitive | fValue.primitive) separator (', ')][if (prim.dataType.toString() = 'String' or prim.dataType.toString() = 'Date' or prim.dataType.toString() = 'DateTime')]'[prim.value/]'[else][prim.value/][/if][/for][']'/]

[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed=data_transformations.transform_filter_rows_primitive(data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed,
																										columns=columns_[fValue.filterValueDef.name/],
																	                                    filter_fix_value_list=filter_fix_value_list_[fValue.filterValueDef.name/],
																										filter_type=FilterType([if (fValue.filterType=FilterType::EXCLUDE)]0[else]1[/if]))
							[/if]																																		[comment CLOSE checks that the list of primitives is not empty/]
							[if (not fValue.matchingvalue->isEmpty())]																									[comment OPEN checks that the list of MatchingValues is not empty/]
								[let filteredSet : OrderedSet(SpecialValues) = fValue.matchingvalue->select(e | e.oclIsKindOf(SpecialValues))]							[comment OPEN assigns to a set only the SpecialValues/]
									[if (not filteredSet->isEmpty())]																									[comment OPEN checks that list of SpecialValues is not empty/]
dicc_[fValue.filterValueDef.name/]={[for (df : DataField | dd_in.datafield) separator (', ')]'[df.displayName/]':{[for (spVal : SpecialValues | filteredSet) separator (', ')][if (spVal.specialType=SpecialValue::Missing)]'missing': ['['/][for (mv : ValueField | df.missingValues) separator(', ')][if (df.dataType=DataType::String or df.dataType=DataType::Time or df.dataType=DataType::DateTime)]'[mv.value/]'[else][mv.value/][/if][/for][']'/][elseif(spVal.specialType=SpecialValue::Invalid)]'invalid': ['['/][for (iv : ValueField | df.invalidValues) separator(', ')][if (df.dataType=DataType::String or df.dataType=DataType::Time or df.dataType=DataType::DateTime)]'[iv.value/]'[else][iv.value/][/if][/for][']'/] [elseif(spVal.specialType=SpecialValue::Outlier)]'outlier': True[/if][/for]}[/for]}

[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed=data_transformations.transform_filter_rows_special_values(data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed,
																										cols_special_type_values=dicc_[fValue.filterValueDef.name/],
																										filter_type=FilterType([if (fValue.filterType=FilterType::EXCLUDE)]0[else]1[/if]))
									[/if]																																[comment CLOSE checks that list of SpecialValues is not empty/]
								[/let]																																	[comment CLOSE assigns to a set only the SpecialValues/]
								[let filteredSet : OrderedSet(Range) = fValue.matchingvalue->select(e | e.oclIsKindOf(Range))]											[comment OPEN assigns to a set only the Range/]
									[if (not filteredSet->isEmpty())]																									[comment OPEN checks that the list of Range is not empty/]
filter_range_left_values_list_[fValue.filterValueDef.name/]=['['/][for (range : Range | filteredSet) separator(', ')][if (range.minInfinity=true)]-np.inf[else][range.min/][/if][/for][']'/]
filter_range_right_values_list_[fValue.filterValueDef.name/]=['['/][for (range : Range | filteredSet) separator(', ')][if (range.maxInfinity=true)]np.inf[else][range.max/][/if][/for][']'/]
closure_type_list_[fValue.filterValueDef.name/]=['['/][for (range : Range | filteredSet) separator(', ')]Closure([if (range.clousure=ClosureType::openOpen)]0[elseif(range.clousure=ClosureType::openClosed)]1[elseif(range.clousure=ClosureType::closedOpen)]2[elseif(range.clousure=ClosureType::closedClosed)]3[/if])[/for][']'/]

[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed=data_transformations.transform_filter_rows_range(data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed,
																										columns=columns_[fValue.filterValueDef.name/],
																										left_margin_list=filter_range_left_values_list_[fValue.filterValueDef.name/],
																										right_margin_list=filter_range_right_values_list_[fValue.filterValueDef.name/],
																										filter_type=FilterType([if (fValue.filterType=FilterType::EXCLUDE)]0[else]1[/if]),
																										closure_type_list=closure_type_list_[fValue.filterValueDef.name/])
									[/if]																																[comment CLOSE checks that the list of Range is not empty/]
								[/let]																																	[comment CLOSE assigns to a set only the Range/]
							[/if]																																		[comment CLOSE checks that the list of MatchingValues is not empty/]
						[/let]																																			[comment CLOSE assigns the variable to be a FilterValue/]
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed
						[if (dw_modified.dataProcessingDefinition.oclIsKindOf(Library::DataProcessingDefinition))]														[comment OPEN checks if the DataProcessing contains a DataProcessingDefinition/]
							[let dpd : Library::DataProcessingDefinition = dw_modified.dataProcessingDefinition.oclAsType(Library::DataProcessingDefinition)]			[comment OPEN assigns the variable to be a DataProcessingDefinition/]
								[if (dpd.oclIsKindOf(Library::Transformation))]																							[comment OPEN checks if the DataProcessingDefinition is a Transformation/]
									[let libT : Library::Transformation = dpd.oclAsType(Library::Transformation)]														[comment OPEN assigns the variable to be a Transformation/]
										[if (dataProcessing.eContainer(Workflow).environment.oclIsKindOf(Local))]														[comment OPEN checks if the Environment is Local/]
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df.to_parquet('[if (dataProcessing.eContainer(Workflow).environment.path.startsWith('.'))][dataProcessing.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][dataProcessing.eContainer(Workflow).environment.path/][/if]/data/[if (dd_in.out.fileName.trim().indexOf('.')>0)][dd_in.out.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_in.out.fileName.trim()/].parquet[/if]')
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet('[if (dataProcessing.eContainer(Workflow).environment.path.startsWith('.'))][dataProcessing.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][dataProcessing.eContainer(Workflow).environment.path/][/if]/data/[if (dd_in.out.fileName.trim().indexOf('.')>0)][dd_in.out.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_in.out.fileName.trim()/].parquet[/if]')
										[/if]																															[comment CLOSE checks if the Environment is Local/]
									[/let]																																[comment CLOSE assigns the variable to be a Transformation/]
								[elseif (dpd.oclIsKindOf(Library::Job))]																								[comment OPEN checks if the DataProcessingDefinition is a Job/]
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df.to_parquet([dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/])	
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet([dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/])
								[/if]																																	[comment CLOSE checks if the DataProcessingDefinition is a Transformation or a Job/]
							[/let]																																		[comment CLOSE assigns the variable to be a DataProcessingDefinition/]
						[/if]																																			[comment CLOSE checks if the DataProcessing contains a DataProcessingDefinition/]
					[/for]																																				[comment CLOSE traverse all the input DataDictionaries/]
				[/if]																																					[comment CLOSE checks that the parameter is a FilterValue/]
			[/if]																																						[comment CLOSE checks that the DataProcessing is rowFilter/]
			[if (dataProcessing.dataProcessingDefinition.name='columnFilter')]																							[comment OPEN checks that the DataProcessing is columnFilter/]
				[if (p.oclIsKindOf(FieldRange))]																																[comment OPEN checks that the parameter is a Field/]
					[let field : FieldRange = p.oclAsType(FieldRange)]																											[comment OPEN assigns the variable to be a field/]
						[for (dd_in : DataDictionary | dataProcessing.inputPort)]																						[comment OPEN traverse all the input DataDictionaries/]
field_list_[field.fieldDef.name/]=['['/][for (df : DataField | field.dataField) separator (', ')]'[df.displayName/]'[/for][']'/]
							[for (df : DataField | dd_in.datafield)]
								[if (df.oclIsTypeOf(Continuous) and df.oclAsType(Continuous).numDecimals <> null)]
								[/if]
							[/for]
[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed=data_transformations.transform_filter_columns(data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed,
																columns=field_list_[field.fieldDef.name/], belong_op=Belong.[field.operator/])

[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed
							[if (dw_modified.dataProcessingDefinition.oclIsKindOf(Library::DataProcessingDefinition))]													[comment OPEN checks if the DataProcessing contains a DataProcessingDefinition/]
								[let dpd : Library::DataProcessingDefinition = dw_modified.dataProcessingDefinition.oclAsType(Library::DataProcessingDefinition)]		[comment OPEN assigns the variable to be a DataProcessingDefinition/]
									[if (dpd.oclIsKindOf(Library::Transformation))]																						[comment OPEN checks if the DataProcessingDefinition is a Transformation/]
										[let libT : Library::Transformation = dpd.oclAsType(Library::Transformation)]													[comment OPEN assigns the variable to be a Transformation/]
											[if (dataProcessing.eContainer(Workflow).environment.oclIsKindOf(Local))]													[comment OPEN checks if the Environment is Local/]
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df.to_parquet('[if (dataProcessing.eContainer(Workflow).environment.path.startsWith('.'))][dataProcessing.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][dataProcessing.eContainer(Workflow).environment.path/][/if]/data/[if (dd_in.out.fileName.trim().indexOf('.')>0)][dd_in.out.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_in.out.fileName.trim()/].parquet[/if]')
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet('[if (dataProcessing.eContainer(Workflow).environment.path.startsWith('.'))][dataProcessing.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][dataProcessing.eContainer(Workflow).environment.path/][/if]/data/[if (dd_in.out.fileName.trim().indexOf('.')>0)][dd_in.out.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_in.out.fileName.trim()/].parquet[/if]')
											[/if]																														[comment CLOSE checks if the Environment is Local/]
										[/let]																															[comment CLOSE assigns the variable to be a Transformation/]
									[elseif (dpd.oclIsKindOf(Library::Job))]																							[comment OPEN checks if the DataProcessingDefinition is a Job/]
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df.to_parquet([dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/])	
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet([dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/])
									[/if]																																[comment CLOSE checks if the DataProcessingDefinition is a Transformation or a Job/]
								[/let]																																	[comment CLOSE assigns the variable to be a DataProcessingDefinition/]
							[/if]																																		[comment CLOSE checks if the DataProcessing contains a DataProcessingDefinition/]
						[/for]																																			[comment CLOSE traverse all the input DataDictionaries/]
					[/let]																																				[comment CLOSE assigns the variable to be a field/]
				[/if]																																					[comment CLOSE checks that the parameter is a Field/]
			[/if]																																						[comment CLOSE checks that the DataProcessing is columnFilter/]
			[if (dataProcessing.dataProcessingDefinition.name='mathOperation')]
				[if (p.oclIsKindOf(MathOp))]
					[let mathOp : MathOp = p.oclAsType(MathOp)]
						[for (dd_in : DataDictionary | dataProcessing.inputPort)]
							[for (df : DataField | dd_in.out.datafield)]
								[if (df.oclIsTypeOf(Continuous) and df.oclAsType(Continuous).numDecimals <> null)]
								[/if]
[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed=data_transformations.transform_math_operation(data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed,
															[if (mathOp.operator=MathOperator::SUM)]math_op=MathOperator(0)[elseif (mathOp.operator=MathOperator::SUBSTRACT)]math_op=MathOperator(1)[elseif (mathOp.operator=MathOperator::MULTIPLY)]math_op=MathOperator(2)[elseif (mathOp.operator=MathOperator::DIVIDE)]math_op=MathOperator(3)[/if], field_out='[df.displayName/]',
															[for (operand : Operand | mathOp.operand)][if (operand.next_operand<>null)][if (operand.oclIsKindOf(Field))][let fop : Field = operand.oclAsType(Field)]firstOperand='[fop.datafield.displayName/]', isFieldFirst=True,[/let][else][let fop : FixValue = operand.oclAsType(FixValue)]firstOperand=[fop.value.value/], isFieldFirst=False,[/let][/if][if (operand.next_operand.oclIsKindOf(Field))][let sop : Field = operand.next_operand.oclAsType(Field)]secondOperand='[sop.datafield.displayName/]', isFieldSecond=True[/let][else][let sop : FixValue = operand.next_operand.oclAsType(FixValue)]secondOperand=[sop.value.value/], isFieldSecond=False[/let][/if][/if][/for])
							[/for]

[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed
							[if (dw_modified.dataProcessingDefinition.oclIsKindOf(Library::DataProcessingDefinition))]													[comment OPEN checks if the DataProcessing contains a DataProcessingDefinition/]
								[let dpd : Library::DataProcessingDefinition = dw_modified.dataProcessingDefinition.oclAsType(Library::DataProcessingDefinition)]		[comment OPEN assigns the variable to be a DataProcessingDefinition/]
									[if (dpd.oclIsKindOf(Library::Transformation))]																						[comment OPEN checks if the DataProcessingDefinition is a Transformation/]
										[let libT : Library::Transformation = dpd.oclAsType(Library::Transformation)]													[comment OPEN assigns the variable to be a Transformation/]
											[if (dataProcessing.eContainer(Workflow).environment.oclIsKindOf(Local))]													[comment OPEN checks if the Environment is Local/]
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df.to_parquet('[if (dataProcessing.eContainer(Workflow).environment.path.startsWith('.'))][dataProcessing.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][dataProcessing.eContainer(Workflow).environment.path/][/if]/data/[if (dd_in.out.fileName.trim().indexOf('.')>0)][dd_in.out.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_in.out.fileName.trim()/].parquet[/if]')
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet('[if (dataProcessing.eContainer(Workflow).environment.path.startsWith('.'))][dataProcessing.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][dataProcessing.eContainer(Workflow).environment.path/][/if]/data/[if (dd_in.out.fileName.trim().indexOf('.')>0)][dd_in.out.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_in.out.fileName.trim()/].parquet[/if]')
											[/if]																														[comment CLOSE checks if the Environment is Local/]
										[/let]																															[comment CLOSE assigns the variable to be a Transformation/]
									[elseif (dpd.oclIsKindOf(Library::Job))]																							[comment OPEN checks if the DataProcessingDefinition is a Job/]
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df.to_parquet([dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/])	
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet([dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/])
									[/if]																																[comment CLOSE checks if the DataProcessingDefinition is a Transformation or a Job/]
								[/let]																																	[comment CLOSE assigns the variable to be a DataProcessingDefinition/]
							[/if]																																		[comment CLOSE checks if the DataProcessing contains a DataProcessingDefinition/]
						[/for]
					[/let]
				[/if]
			[/if]
			[if (dataProcessing.dataProcessingDefinition.name='join')]
				[if (p.oclIsKindOf(Join))]
					[let join : Join = p.oclAsType(Join)]
dictionary_[join.joinDef.name/]={[for (operand : Operand | join.operand)][if (operand.previous_operand=null)][if (operand.oclIsKindOf(Field))][let field : Field=operand.oclAsType(Field)]'[field.datafield.displayName/]': True[/let][elseif (operand.oclIsKindOf(FixValue))][let fv : FixValue=operand.oclAsType(FixValue)]'[fv.value.value/]': False[/let][/if][if (operand.next_operand<>null)][joinOperands(operand.next_operand)/][/if][/if][/for]}

						[for (dd_in : DataDictionary | dataProcessing.inputPort)]
							[for (df : DataField | dd_in.out.datafield)]
								[if (df.oclIsTypeOf(Continuous) and df.oclAsType(Continuous).numDecimals <> null)]
								[/if]
[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed=data_transformations.transform_join(data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed,
																dictionary=dictionary_[join.joinDef.name/], field_out='[df.displayName/]')

							[/for]

[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_transformed
							[if (dw_modified.dataProcessingDefinition.oclIsKindOf(Library::DataProcessingDefinition))]													[comment OPEN checks if the DataProcessing contains a DataProcessingDefinition/]
								[let dpd : Library::DataProcessingDefinition = dw_modified.dataProcessingDefinition.oclAsType(Library::DataProcessingDefinition)]		[comment OPEN assigns the variable to be a DataProcessingDefinition/]
									[if (dpd.oclIsKindOf(Library::Transformation))]																						[comment OPEN checks if the DataProcessingDefinition is a Transformation/]
										[let libT : Library::Transformation = dpd.oclAsType(Library::Transformation)]													[comment OPEN assigns the variable to be a Transformation/]
											[if (dataProcessing.eContainer(Workflow).environment.oclIsKindOf(Local))]													[comment OPEN checks if the Environment is Local/]
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df.to_parquet('[if (dataProcessing.eContainer(Workflow).environment.path.startsWith('.'))][dataProcessing.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][dataProcessing.eContainer(Workflow).environment.path/][/if]/data/[if (dd_in.out.fileName.trim().indexOf('.')>0)][dd_in.out.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_in.out.fileName.trim()/].parquet[/if]')
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet('[if (dataProcessing.eContainer(Workflow).environment.path.startsWith('.'))][dataProcessing.eContainer(Workflow).environment.path.replaceFirst('./', '/')/][else][dataProcessing.eContainer(Workflow).environment.path/][/if]/data/[if (dd_in.out.fileName.trim().indexOf('.')>0)][dd_in.out.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][dd_in.out.fileName.trim()/].parquet[/if]')
											[/if]																														[comment CLOSE checks if the Environment is Local/]
										[/let]																															[comment CLOSE assigns the variable to be a Transformation/]
									[elseif (dpd.oclIsKindOf(Library::Job))]																							[comment OPEN checks if the DataProcessingDefinition is a Job/]
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df.to_parquet([dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/])	
[dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/]_df=pd.read_parquet([dd_in.out.name.replaceAll('[(),-/\\s]+', '_')/])
									[/if]																																[comment CLOSE checks if the DataProcessingDefinition is a Transformation or a Job/]
								[/let]																																	[comment CLOSE assigns the variable to be a DataProcessingDefinition/]
							[/if]																																		[comment CLOSE checks if the DataProcessing contains a DataProcessingDefinition/]
						[/for]
					[/let]
				[/if]
			[/if]
		[/for]																																							[comment CLOSE traverse all the parameters in the DataProcessing/]
	[/if]																																							[comment CLOSE checks that the DataProcessing is not a Mapping/]
[/if]																																							[comment CLOSE checks that there are parameters in the DataProcessing/]
[/template]


[template public joinOperands(operand : Operand)]
[if (operand.oclIsKindOf(Field))][let field : Field=operand.oclAsType(Field)], '[field.datafield.displayName/]': True[/let][elseif (operand.oclIsKindOf(FixValue))][let fv : FixValue=operand.oclAsType(FixValue)], '[fv.value.value/]': False[/let][/if][if (operand.next_operand<>null)][joinOperands(operand.next_operand)/][/if]
[/template]


[template public generateDataSmells(dataProcessing : DataProcessing)]
[for (dd_in : DataDictionary | dataProcessing.inputPort)]
	[for (df : DataField | dd_in.datafield)]
		[if (df.oclIsKindOf(Continuous) and df.oclAsType(Continuous).numDecimals<>null)]
data_smells.check_precision_consistency(data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df,
										expected_decimals=[df.oclAsType(Continuous).numDecimals/], field='[df.displayName/]')
		[/if]
	[/for]
[/for]

common_invalid_list=['['/]'inf', '-inf', 'nan'[']'/]
common_missing_list=['['/]'', '?', '.','null','none','na'[']'/]

[for (dd_in : DataDictionary | dataProcessing.inputPort)]
	[for (df : DataField | dd_in.datafield)]
list_missing=['['/][for (v : ValueField | df.missingValues) separator(',')][if (df.dataType=DataType::Integer or df.dataType=DataType::Float or df.dataType=DataType::Boolean or df.dataType=DataType::Double)][v.value/][else]'[v.value/]'[/if][/for][']'/]
list_invalid=['['/][for (v : ValueField | df.invalidValues) separator(',')][if (df.dataType=DataType::Integer or df.dataType=DataType::Float or df.dataType=DataType::Boolean or df.dataType=DataType::Double)][v.value/][else]'[v.value/]'[/if][/for][']'/]

data_smells.check_missing_invalid_value_consistency(data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df, 
													missing_invalid_list=[if (df.missingValues->isEmpty() and not df.invalidValues->isEmpty())]list_invalid, common_missing_invalid_list=common_invalid_list[elseif (not df.missingValues->isEmpty() and df.invalidValues->isEmpty())]list_missing, common_missing_invalid_list=common_missing_list[else]['['/][']'/], common_missing_invalid_list=common_missing_list[/if], field='[df.displayName/]')
	[/for]
[/for]

[for (dd_in : DataDictionary | dataProcessing.inputPort)]
	[for (df : DataField | dd_in.datafield)]
data_smells.check_integer_as_floating_point(data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df, field='[df.displayName/]')
	[/for]
[/for]

[for (dd_in : DataDictionary | dataProcessing.inputPort)]
	[for (df : DataField | dd_in.datafield)]
data_smells.check_types_as_string(data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df, field='[df.displayName/]', expected_type=DataType.[df.dataType.toString().toUpperCase()/])
	[/for]
[/for]

[for (dd_in : DataDictionary | dataProcessing.inputPort)]
	[for (df : DataField | dd_in.datafield)]
data_smells.check_special_character_spacing(data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df, field='[df.displayName/]')
	[/for]
[/for]

[for (dd_in : DataDictionary | dataProcessing.inputPort)]
	[for (df : DataField | dd_in.datafield)]
data_smells.check_suspect_precision(data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df, field='[df.displayName/]')
	[/for]
[/for]

[for (dd_in : DataDictionary | dataProcessing.inputPort)]
	[for (df : DataField | dd_in.datafield)]
		[if (df.oclIsKindOf(Continuous))]
			[let cont : Continuous = df.oclAsType(Continuous)]
				[for (interval : Interval | cont.interval)]
data_smells.check_suspect_distribution(data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df, min_value=[interval.leftMargin/], max_value=[interval.rightMargin/], field='[df.displayName/]')
				[/for]
			[/let]
		[/if]
	[/for]
[/for]

[for (dd_in : DataDictionary | dataProcessing.inputPort)]
	[for (df : DataField | dd_in.datafield)]
data_smells.check_date_as_datetime(data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df, field='[df.displayName/]')
	[/for]
[/for]

[for (dd_in : DataDictionary | dataProcessing.inputPort)]
	[for (df : DataField | dd_in.datafield)]
		[if (dataProcessing.eContainer(Workflow).environment.storage->first().oclIsKindOf(Folder))]
			[let folder : Folder = dataProcessing.eContainer(Workflow).environment.storage->first().oclAsType(Folder)]
data_smells.check_separating_consistency(data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df, decimal_sep='[folder.file->first().csv_decimalSep/]', thousand_sep='[folder.file->first().csv_thousandsSep/]', field='[df.displayName/]')
			[/let]
		[else]
data_smells.check_separating_consistency(data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df, field='[df.displayName/]')
		[/if]
	[/for]
[/for]

[for (dd_in : DataDictionary | dataProcessing.inputPort)]
	[for (df : DataField | dd_in.datafield)]
		[if (df.oclIsKindOf(Date))]
			[let dfDate : Date = df.oclAsType(Date)]
data_smells.check_date_time_consistency(data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df, expected_type=DataType.[dfDate.dataType.toString().toUpper()/], field='[df.displayName/]')
			[/let]
		[/if]
	[/for]
[/for]

[for (dd_in : DataDictionary | dataProcessing.inputPort)]
	[for (df : DataField | dd_in.datafield)]
data_smells.check_ambiguous_datetime_format(data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df, field='[df.displayName/]')
	[/for]
[/for]

[for (dd_in : DataDictionary | dataProcessing.inputPort)]
	[for (df : DataField | dd_in.datafield)]
		[if (df.oclIsKindOf(Date))]
			[let date : Date = df.oclAsType(Date)]
				[for (intervalDate : IntervalDate | date.interval)]
data_smells.check_suspect_date_value(data_dictionary=[dd_in.name.replaceAll('[(),-/\\s]+', '_')/]_df, min_value='[intervalDate.leftMargin/]', max_value='[intervalDate.rightMargin/]', field='[df.displayName/]')
				[/for]
			[/let]
		[/if]
	[/for]
[/for]
[/template]


[template public generateEnvironment(aWorkflow : Workflow)]
[if (aWorkflow.environment<>null)]
	[if (aWorkflow.environment.oclIsKindOf(Local))]
[generateLocalDocker()/]
	[elseif (aWorkflow.environment.oclIsKindOf(AzureCI) or aWorkflow.environment.oclIsKindOf(AmazonECS))]
[generateRemoteDocker()/]
	[/if]
[/if]
[/template]


[template public generateRemoteDocker(aWorkflow : Workflow)]
[if (aWorkflow.environment.oclIsTypeOf(AmazonECS))]
[generateAmazonECS()/]
[elseif (aWorkflow.environment.oclIsTypeOf(AzureCI))]
[generateAzureCI()/]
[/if]
[/template]


[template public generateLocalDocker(aWorkflow : Workflow)]
[let doc : Local = aWorkflow.environment.oclAsType(Local)]																					[comment OPEN assigns the Environment to be Local/]
	[file ('Dockerfile', false, 'UTF-8')]																									[comment OPEN generates the Dockerfile/]
		[if (doc.developmentTool.tool=TOOL::PYTHON)]																						[comment OPEN checks if the development tool is Python/]
FROM python:[doc.developmentTool.version/]-slim
		[elseif (doc.developmentTool.tool=TOOL::KNIME)]																						[comment OPEN checks if the development tool is KNIME/]
FROM python:3.11-slim
#FROM KNIME:[doc.developmentTool.version/]
		[elseif (doc.developmentTool.tool=TOOL::R)]																							[comment OPEN checks if the development tool is R/]
FROM python:3.11-slim
#FROM R:[doc.developmentTool.version/]
		[/if]																																[comment CLOSE checks the type of the development/]

WORKDIR [aWorkflow.environment.path/]
ENV PYTHONPATH=[aWorkflow.environment.path/]

RUN apt-get update && \
    apt-get install -y --no-install-recommends wget git && \
    rm -rf /var/lib/apt/lists/*

RUN git clone --depth 1 --branch develop https://github.com/i3uex/MD4DSP-m2python.git .

RUN wget https://download.java.net/java/ga/jdk11/openjdk-11_linux-x64_bin.tar.gz && \
    tar -xvf openjdk-11_linux-x64_bin.tar.gz -C /usr/local && \
    ln -s /usr/local/jdk-11/bin/java /usr/bin/java

RUN pip install --no-cache-dir -r requirements.txt
RUN pip install h5py
RUN pip install pyarrow
[let filteredSet : OrderedSet(Database) = aWorkflow.environment.storage->select(e | e.oclIsKindOf(Database))]								[comment OPEN creates a set only with databases/]
	[if (not filteredSet->isEmpty())]																										[comment OPEN checks if the set is not empty/]
RUN pip install sqlalchemy
		[let types : Set(Environment::DBTYPE) = filteredSet->collect(e | e.type)->asSet()]													[comment OPEN creates a set only with the type of the databases/]
			[for (type : DBTYPE | types)]																									[comment OPEN traverse all the types for the databases/]
				[if (type=DBTYPE::MYSQL)]																									[comment OPEN checks if the database is Mysql/]
RUN pip install mysql-connector-python --upgrade
				[elseif (type=DBTYPE::POSTGRESQL)]																							[comment OPEN checks if the database is PostgreSQL/]
RUN pip install psycopg2-binary
				[elseif (type=DBTYPE::SQLSERVER)]																							[comment OPEN checks if the database is SQLServer/]
RUN pip3 install pyodbc
RUN apt-get update && \
    apt-get install -y curl gnupg apt-transport-https unixodbc-dev && \
    curl https://packages.microsoft.com/keys/microsoft.asc | apt-key add - && \
    curl https://packages.microsoft.com/config/ubuntu/20.04/prod.list > /etc/apt/sources.list.d/mssql-release.list && \
    apt-get update && ACCEPT_EULA=Y apt-get install -y msodbcsql17 && \
    rm -rf /var/lib/apt/lists/*
				[elseif (type=DBTYPE::ORACLE)]																								[comment OPEN checks if the database is Oracle/]
RUN pip install oracledb
				[elseif (type=DBTYPE::MONGODB)]																								[comment OPEN checks if the database is MongoDB/]
RUN pip install pymongo
				[elseif (type=DBTYPE::DYNAMODB)]																							[comment OPEN checks if the database is DynamoDB/]
RUN pip install boto3
				[/if]																														[comment CLOSE checks the type of the database/]
			[/for]																															[comment CLOSE traverse all the types for the databases/]
		[/let]																																[comment CLOSE creates a set only with the type of the databases/]
	[/if]																																	[comment CLOSE checks if the set is not empty/]
[/let]																																		[comment CLOSE creates a set only with databases/]

COPY dataProcessing_Job_[aWorkflow.name.replaceAll('[(),-/\\s]+', '_')/].py [aWorkflow.environment.path/]/workflows/
COPY contracts_Job_[aWorkflow.name.replaceAll('[(),-/\\s]+', '_')/].py [aWorkflow.environment.path/]/workflows/
COPY transformations_Job_[aWorkflow.name.replaceAll('[(),-/\\s]+', '_')/].py [aWorkflow.environment.path/]/workflows/

COPY fileFormatting.py [aWorkflow.environment.path/]/workflows/

COPY workflow_scripts.sh [aWorkflow.environment.path/]/workflow_scripts.sh

RUN chmod +x [aWorkflow.environment.path/]/workflow_scripts.sh

CMD ['['/]"/bin/bash", "[aWorkflow.environment.path/]/workflow_scripts.sh"[']'/]
	[/file]																																	[comment CLOSE generates the Dockerfile/]


	[file ('deploy_docker_app.sh', false, 'UTF-8')]																							[comment OPEN generates the deploy_docker_app/]
#!/bin/bash
set -e

if ['['/] ! -d "data" [']'/]; then
    mkdir -p data
fi

[for (ps : ProcessingStep | doc.eContainer(Workflow).dataprocessing)]																		[comment OPEN traverse all the ProcessingSteps in the workflow/]
	[for (dd_in : DataDictionary | ps.inputPort)]																							[comment OPEN traverse all the input DataDictionaries in the ProcessingStep/]
		[if (dd_in.fileName.trim().contains('/'))]																							[comment OPEN checks if the fileName is absolute/]
if ['['/] ! -d "data/[dd_in.fileName.trim().replaceAll('/[^/]*$', '')/]" [']'/]; then
    mkdir -p data/[dd_in.fileName.trim().replaceAll('/[^/]*$', '')/]
fi
		[/if]																																[comment CLOSE checks if the fileName is absolute/]
	[/for]																																	[comment CLOSE traverse all the input DataDictionaries in the ProcessingStep/]
	[for (dd_out : DataDictionary | ps.outputPort)]																							[comment OPEN traverse all the output DataDictionaries in the ProcessingStep/]
		[if (dd_out.fileName.trim().contains('/'))]																							[comment OPEN checks if the fileName is absolute/]
if ['['/] ! -d "data/[dd_out.fileName.trim().replaceAll('/[^/]*$', '')/]" [']'/]; then
    mkdir -p data/[dd_out.fileName.trim().replaceAll('/[^/]*$', '')/]
fi
		[/if]																																[comment CLOSE checks if the fileName is absolute/]
	[/for]																																	[comment CLOSE traverse all the output DataDictionaries in the ProcessingStep/]
[/for]																																		[comment CLOSE traverse all the ProcessingSteps in the workflow/]
#sudo apt-get update --yes
#sudo apt-get install ca-certificates curl
#sudo install -m 0755 -d /etc/apt/keyrings
#sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
#sudo chmod a+r /etc/apt/keyrings/docker.asc

#echo \
#  "deb ['['/]arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
#  $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
#  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
#sudo apt-get update --yes

#sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin --yes

docker build --no-cache -t [doc.imageName.replaceAll('[(),-/\\s]+', '_')/]:[doc.imageTag.replaceAll('[(),-/\\s]+', '_')/] -f Dockerfile .

clear

[for (st: Storage | doc.storage)]																											[comment OPEN traverse all the storages in the environment/]
	[if (st.oclIsKindOf(LocalFolder))]																										[comment OPEN checks if the storage is a LocalFolder/]
		[let lf : LocalFolder = st.oclAsType(LocalFolder)]																					[comment OPEN assigns the variable to be a LocalFolder/]
			[for (fi : File | lf.file)]																										[comment OPEN traverse all the files in the folder/]
				[if (fi.dataDictionary.fileName.trim().indexOf('.')>0)]																		[comment OPEN checks if the file contains a ./]
cp [lf.folderPath/]/[fi.dataDictionary.fileName.trim().replaceAll('.*/', '')/] "$(pwd)/data/"[if (fi.dataDictionary.fileName.trim().contains('/'))][fi.dataDictionary.fileName.trim().replaceAll('/[^/]*$', '')/][/if]
				[elseif (fi.type=FileType::CSV or fi.type=FileType::FEATHER or fi.type=FileType::JSON or fi.type=FileType::PARQUET)]		[comment OPEN checks the extension of the file/]
cp [lf.folderPath/]/[fi.dataDictionary.fileName.trim().replaceAll('.*/', '')/].[fi.type.toString().toLowerCase()/] "$(pwd)/data/"[if (fi.dataDictionary.fileName.trim().contains('/'))][fi.dataDictionary.fileName.trim().replaceAll('/[^/]*$', '')/][/if]
				[elseif (fi.type=FileType::HDF5)]																							[comment OPEN checks the extension of the file/]
cp [lf.folderPath/]/[fi.dataDictionary.fileName.trim().replaceAll('.*/', '')/].hdf "$(pwd)/data/"[if (fi.dataDictionary.fileName.trim().contains('/'))][fi.dataDictionary.fileName.trim().replaceAll('/[^/]*$', '')/][/if]
				[elseif (fi.type=FileType::EXCEL)]																							[comment OPEN checks the extension of the file/]
cp [lf.folderPath/]/[fi.dataDictionary.fileName.trim().replaceAll('.*/', '')/].xlsx "$(pwd)/data/"[if (fi.dataDictionary.fileName.trim().contains('/'))][fi.dataDictionary.fileName.trim().replaceAll('/[^/]*$', '')/][/if]
				[/if]																														[comment CLOSE checks the extension of the file/]
			[/for]																															[comment CLOSE traverse all the files in the folder/]
		[/let]																																[comment CLOSE assigns the variable to be a LocalFolder/]
	[/if]																																	[comment CLOSE checks if the storage is a LocalFolder/]
[/for]																																		[comment CLOSE traverse all the storages in the environment/]


[for (ps : ProcessingStep | doc.eContainer(Workflow).dataprocessing)]																		[comment OPEN traverse all the ProcessingStep in the workflow/]
	[if (ps.dataProcessingDefinition.oclIsKindOf(Library::DataProcessingDefinition))]														[comment OPEN checks if the ProcessingStep contains a DataProcessingDefinition/]
		[let dpd : Library::DataProcessingDefinition = ps.dataProcessingDefinition.oclAsType(Library::DataProcessingDefinition)]			[comment OPEN assigns the variable to be a DataProcessingDefinition/]
			[if (dpd.oclIsKindOf(Library::Transformation))]																					[comment OPEN checks if the DataProcessingDefinition is a Transformation/]
				[let libT : Library::Transformation = dpd.oclAsType(Library::Transformation)]												[comment OPEN assigns the variable to be a Transformation/]
					[if (ps.oclIsKindOf(PMMLModel))]																						[comment OPEN checks if the ProcessingStep is a PMMLModel/]
						[let pmml : PMMLModel = ps.oclAsType(PMMLModel)]																	[comment OPEN assigns the variable to be a PMMLModel/]
cp [pmml.filePath/] "$(pwd)/data"
						[/let]																												[comment CLOSE assigns the variable to be a PMMLModel/]
					[/if]																													[comment CLOSE checks if the ProcessingStep is a PMMLModel/]
				[/let]																														[comment CLOSE assigns the variable to be a Transformation/]
			[elseif (dpd.oclIsKindOf(Library::Job))]																						[comment OPEN checks if the DataProcessingDefinition is a Job/]
				[let libJ : Library::Job = dpd.oclAsType(Library::Job)]																		[comment OPEN assigns the variable to be a Job/]
					[for (pstep : ProcessingStep | libJ.workflow.dataprocessing)]															[comment OPEN traverse all the ProcessingSteps in the original workflow/]
						[if (pstep.oclIsKindOf(PMMLModel))]																					[comment OPEN checks if the ProcessingStep is a PMMLModel/]
							[let pmml : PMMLModel = pstep.oclAsType(PMMLModel)]																[comment OPEN assigns the variable to be a PMMLModel/]
cp [pmml.filePath/] "$(pwd)/data"
							[/let]																											[comment CLOSE assigns the variable to be a PMMLModel/]
						[/if]																												[comment CLOSE checks if the ProcessingStep is a PMMLModel/]
					[/for]																													[comment CLOSE traverse all the ProcessingSteps in the original workflow/]
				[/let]																														[comment CLOSE assigns the variable to be a Job/]
			[/if]																															[comment CLOSE checks if the DataProcessingDefinition is a Transformation or a Job/]
		[/let]																																[comment CLOSE assigns the variable to be a DataProcessingDefinition/]
	[/if]																																	[comment CLOSE checks if the ProcessingStep contains a DataProcessingDefinition/]
[/for]																																		[comment CLOSE traverse all the ProcessingStep in the workflow/]


docker run -it --rm --name [doc.containerName.replaceAll('[(),-/\\s]+', '_')/] --network host --mount type=bind,source="$(pwd)/data",target=[if (doc.path.startsWith('.'))][doc.path.replaceFirst('.', '')/][else][doc.path/][/if]/data [doc.imageName.replaceAll('[(),-/\\s]+', '_')/]:[doc.imageTag.replaceAll('[(),-/\\s]+', '_')/]

docker rmi [doc.imageName.replaceAll('[(),-/\\s]+', '_')/]:[doc.imageTag.replaceAll('[(),-/\\s]+', '_')/]

clear

echo -e "Exiting the application...\n"
	[/file]																											[comment CLOSE generates the deploy_docker_app/]
[/let]																												[comment CLOSE assigns the Environment to be Local/]


[file ('workflow_scripts.sh', false, 'UTF-8')]																		[comment OPEN generates the workflow_scripts/]
CONTRACTS_SCRIPT="workflows.contracts_Job_[aWorkflow.name.replaceAll('[(),-/\\s]+', '_')/]"
TRANSFORMATIONS_SCRIPT="workflows.transformations_Job_[aWorkflow.name.replaceAll('[(),-/\\s]+', '_')/]"
WORKFLOW_SCRIPT="workflows.dataProcessing_Job_[aWorkflow.name.replaceAll('[(),-/\\s]+', '_')/]"

python3 -m workflows.fileFormatting


while true; do
    echo -e "\nWhat would you like to do?"
    echo "    1. Execute the Workflow validation contracts"
    echo "    2. Execute the Workflow data transformations"
    echo "    3. Execute the complete Pipeline (transformations and contracts)"
    echo -e "    4. Exit\n"

    read -r -p "Select an option: " option
    clear

	if ['['/] "$option" -eq 1 [']'/]; then
        echo -e "Executing the Workflow validation contracts...\n"
        if ! python3 -m $CONTRACTS_SCRIPT; then
            echo "An error occurred while executing the Workflow validation contracts."
        fi
    elif ['['/] "$option" -eq 2 [']'/]; then
        echo -e "Executing the Workflow data transformations...\n"
        if ! python3 -m $TRANSFORMATIONS_SCRIPT; then
            echo "An error occurred while executing the Workflow data transformations."
        fi
    elif ['['/] "$option" -eq 3 [']'/]; then
        echo -e "Executing the complete Pipeline...\n"
        if ! python3 -m $WORKFLOW_SCRIPT; then
            echo "An error occurred while executing the complete Pipeline."
        fi
    elif ['['/] "$option" -eq 4 [']'/]; then
        break
    else
        echo -e "Invalid option. Please select a valid option.\n"
    fi
done
[/file]																												[comment CLOSE generates the workflow_scripts/]
[/template]


[template public generateAmazonECS(aWorkflow : Workflow)]
[file ('AmazonECSfile', false, 'UTF-8')]
	[let ecs : AmazonECS = aWorkflow.environment.oclAsType(AmazonECS)]
SecretId = [ecs.secretId/]
Region = [ecs.region/]
Key = [ecs.key/]
	[/let]
[/file]


[/template]


[template public generateAzureCI(aWorkflow : Workflow)]
[file ('AzureCIfile', false, 'UTF-8')]
	[let ci : AzureCI = aWorkflow.environment.oclAsType(AzureCI)]
AcrName = [ci.acrName/]
KeyVaultName = [ci.keyVaultName/]
SecretName = [ci.secretName/]
BlobName = [ci.blobName/]
	[/let]
[/file]

[/template]


[template public fileFormatting(aWorkflow : Workflow)]
[file ('fileFormatting.py', false, 'UTF-8')]																				[comment OPEN creates the fileFormatting file/]
import pandas as pd
import json
import h5py
import pyarrow
[let filteredSet : OrderedSet(Database) = aWorkflow.environment.storage->select(e | e.oclIsKindOf(Database))]				[comment OPEN creates a set only with the databases/]
	[if (not filteredSet->isEmpty())]																						[comment OPEN checks if the set is not empty/]
from sqlalchemy import create_engine
		[let types : Set(Environment::DBTYPE) = filteredSet->collect(e | e.type)->asSet()]									[comment OPEN creates a set only with the different types of databases/]
			[for (type : DBTYPE | types)]																					[comment OPEN traverse the types of the databases in the set/]
				[if (type=DBTYPE::MYSQL)]																					[comment OPEN checks if the database is MySQL/]
import mysql.connector
				[elseif (type=DBTYPE::POSTGRESQL)]																			[comment OPEN checks if the database is PostgreSQL/]
import psycopg2
				[elseif (type=DBTYPE::SQLSERVER)]																			[comment OPEN checks if the database is SQLServer/]
import pyodbc
				[elseif (type=DBTYPE::ORACLE)]																				[comment OPEN checks if the database is Oracle/]
import oracledb
				[elseif (type=DBTYPE::MONGODB)]																				[comment OPEN checks if the database is Mongodb/]
import pymongo
from pandas import json_normalize
				[elseif (type=DBTYPE::DYNAMODB)]																			[comment OPEN checks if the database is Dynamodb/]
import boto3
from pandas import json_normalize
				[/if]																										[comment CLOSE checks the type of the database/]
			[/for]																											[comment CLOSE traverse the types of the databases in the set/]
		[/let]																												[comment CLOSE creates a set only with the different types of databases/]
	[/if]																													[comment CLOSE checks if the set is not empty/]
[/let]																														[comment CLOSE creates a set only with the databases/]
[for (st : Storage | aWorkflow.environment.storage)]																		[comment OPEN traverse the storages in the environment/]
	[if (st.oclIsKindOf(LocalFolder))]																						[comment OPEN checks if the storage is a LocalFolder/]
		[let f : Folder = st.oclAsType(Folder)]																				[comment OPEN assigns the variable to be a Folder/]
			[for (fi : File | f.file)]																						[comment OPEN traverse the files in the folder/]
				
				[if (fi.type=FileType::CSV)]																				[comment OPEN checks if the file is csv/]
[fi.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/]=pd.read_csv('[if (aWorkflow.environment.path.startsWith('.'))][aWorkflow.environment.path.replaceFirst('./', '/')/][else][aWorkflow.environment.path/][/if]/data/[if (fi.dataDictionary.fileName.trim().indexOf('.')>0)][fi.dataDictionary.fileName.trim()/][else][fi.dataDictionary.fileName.trim()/].csv[/if]', sep = '[fi.csv_sep/]'[if (fi.csv_thousandsSep<>'""')], thousands = '[fi.csv_thousandsSep/]'[/if], decimal = '[fi.csv_decimalSep/]')
[fi.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/].to_parquet('[if (aWorkflow.environment.path.startsWith('.'))][aWorkflow.environment.path.replaceFirst('./', '/')/][else][aWorkflow.environment.path/][/if]/data/[if (fi.dataDictionary.fileName.trim().indexOf('.')>0)][fi.dataDictionary.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][fi.dataDictionary.fileName.trim()/].parquet[/if]')
				[elseif (fi.type=FileType::EXCEL)]																			[comment OPEN checks if the file is excel/]
[fi.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/]=pd.read_excel('[if (aWorkflow.environment.path.startsWith('.'))][aWorkflow.environment.path.replaceFirst('./', '/')/][else][aWorkflow.environment.path/][/if]/data/[if (fi.dataDictionary.fileName.trim().indexOf('.')>0)][fi.dataDictionary.fileName.trim()/][else][fi.dataDictionary.fileName.trim()/].xlsx[/if]')
[fi.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/].to_parquet('[if (aWorkflow.environment.path.startsWith('.'))][aWorkflow.environment.path.replaceFirst('./', '/')/][else][aWorkflow.environment.path/][/if]/data/[if (fi.dataDictionary.fileName.trim().indexOf('.')>0)][fi.dataDictionary.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][fi.dataDictionary.fileName.trim()/].parquet[/if]')
				[elseif (fi.type=FileType::FEATHER)]																		[comment OPEN checks if the file is feather/]
[fi.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/]=pd.read_feather('[if (aWorkflow.environment.path.startsWith('.'))][aWorkflow.environment.path.replaceFirst('./', '/')/][else][aWorkflow.environment.path/][/if]/data/[if (fi.dataDictionary.fileName.trim().indexOf('.')>0)][fi.dataDictionary.fileName.trim()/][else][fi.dataDictionary.fileName.trim()/].feather[/if]')
[fi.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/].to_parquet('[if (aWorkflow.environment.path.startsWith('.'))][aWorkflow.environment.path.replaceFirst('./', '/')/][else][aWorkflow.environment.path/][/if]/data/[if (fi.dataDictionary.fileName.trim().indexOf('.')>0)][fi.dataDictionary.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][fi.dataDictionary.fileName.trim()/].parquet[/if]')
				[elseif (fi.type=FileType::HDF5)]																			[comment OPEN checks if the file is hdf5/]
[fi.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/]=pd.read_hdf('[if (aWorkflow.environment.path.startsWith('.'))][aWorkflow.environment.path.replaceFirst('./', '/')/][else][aWorkflow.environment.path/][/if]/data/[if (fi.dataDictionary.fileName.trim().indexOf('.')>0)][fi.dataDictionary.fileName.trim()/][else][fi.dataDictionary.fileName.trim()/].hdf5[/if]'[if (fi.hdf5_key<>'')], key='[fi.hdf5_key/]'[/if])
[fi.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/].to_parquet('[if (aWorkflow.environment.path.startsWith('.'))][aWorkflow.environment.path.replaceFirst('./', '/')/][else][aWorkflow.environment.path/][/if]/data/[if (fi.dataDictionary.fileName.trim().indexOf('.')>0)][fi.dataDictionary.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][fi.dataDictionary.fileName.trim()/].parquet[/if]')
				[elseif (fi.type=FileType::JSON)]																			[comment OPEN checks if the file is json/]
[fi.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/]=pd.json_normalize('[if (aWorkflow.environment.path.startsWith('.'))][aWorkflow.environment.path.replaceFirst('./', '/')/][else][aWorkflow.environment.path/][/if]/data/[if (fi.dataDictionary.fileName.trim().indexOf('.')>0)][fi.dataDictionary.fileName.trim()/][else][fi.dataDictionary.fileName.trim()/].json[/if]')
[fi.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/].to_parquet('[if (aWorkflow.environment.path.startsWith('.'))][aWorkflow.environment.path.replaceFirst('./', '/')/][else][aWorkflow.environment.path/][/if]/data/[if (fi.dataDictionary.fileName.trim().indexOf('.')>0)][fi.dataDictionary.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][fi.dataDictionary.fileName.trim()/].parquet[/if]')
				[/if]																										[comment CLOSE checks the type of the file/]
			[/for]																											[comment CLOSE traverse the files in the folder/]
		[/let]																												[comment CLOSE assigns the variable to be a Folder/]
	[elseif (st.oclIsKindOf(Database))]																						[comment OPEN checks if the storage is a Database/]
		[let db : Database = st.oclAsType(Database)]																		[comment OPEN assigns the variable to be a Database/]
			[if (db.type=DBTYPE::MYSQL)]																					[comment OPEN checks if the Database is MySQL/]
				[if (db.auth.oclIsKindOf(Credentials))]																		[comment OPEN checks if the autentication uses credentials/]
					[let cr : Credentials = db.auth.oclAsType(Credentials)]													[comment OPEN assigns the variable to be Credentials/]
engine = create_engine('mysql+mysqlconnector://[cr.username/]:[cr.passwd/]@[db.host/]/[db.dbName/]')
					[/let]																									[comment CLOSE assigns the variable to be Credentials/]
				[elseif (db.auth.oclIsKindOf(OAuth2))]																		[comment OPEN checks if the autentication uses OAuth2/]
					[let oa : OAuth2 = db.auth.oclAsType(OAuth2)]															[comment OPEN assigns the variable to be OAuth2/]
					[/let]																									[comment CLOSE assigns the variable to be OAuth2/]
				[elseif (db.auth.oclIsKindOf(SSL))]																			[comment OPEN checks if the autentication uses SSL/]
					[let ssl : SSL = db.auth.oclAsType(SSL)]																[comment OPEN assigns the variable to be SSL/]
					[/let]																									[comment CLOSE assigns the variable to be SSL/]
				[/if]																										[comment CLOSE checks the autentication type/]
				[for (tab : Table | db.table)]																				[comment OPEN traverse the tables in the database/]
[db.dbName/]_[tab.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/] = pd.read_sql('SELECT * FROM [tab.dataDictionary.fileName.trim().replaceAll('\\.(.*?)(\\s|$)|.*/', '')/];', engine)
[db.dbName/]_[tab.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/].to_parquet('[if (aWorkflow.environment.path.startsWith('.'))][aWorkflow.environment.path.replaceFirst('./', '/')/][else][aWorkflow.environment.path/][/if]/data/[if (tab.dataDictionary.fileName.trim().indexOf('.')>0)][tab.dataDictionary.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][tab.dataDictionary.fileName.trim()/].parquet[/if]')

				[/for]																										[comment CLOSE traverse the tables in the database/]
			[elseif (db.type=DBTYPE::POSTGRESQL)]																			[comment OPEN checks if the Database is PostgreSQL/]
				[if (db.auth.oclIsKindOf(Credentials))]																		[comment OPEN checks if the autentication uses credentials/]
					[let cr : Credentials = db.auth.oclAsType(Credentials)]													[comment OPEN assigns the variable to be Credentials/]													
engine = create_engine('postgresql+psycopg2://[cr.username/]:[cr.passwd/]@[db.host/]/[db.dbName/]')
					[/let]																									[comment CLOSE assigns the variable to be Credentials/]
				[elseif (db.auth.oclIsKindOf(OAuth2))]																		[comment OPEN checks if the autentication uses OAuth2/]
					[let oa : OAuth2 = db.auth.oclAsType(OAuth2)]															[comment OPEN assigns the variable to be OAuth2/]
					[/let]																									[comment CLOSE assigns the variable to be OAuth2/]
				[elseif (db.auth.oclIsKindOf(SSL))]																			[comment OPEN checks if the autentication uses SSL/]
					[let ssl : SSL = db.auth.oclAsType(SSL)]																[comment OPEN assigns the variable to be SSL/]
					[/let]																									[comment CLOSE assigns the variable to be SSL/]
				[/if]																										[comment CLOSE checks the autentication type/]
				[for (tab : Table | db.table)]																				[comment OPEN traverse the tables in the database/]
[db.dbName/]_[tab.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/] = pd.read_sql('SELECT * FROM [tab.dataDictionary.fileName.trim().replaceAll('\\.(.*?)(\\s|$)|.*/', '')/];', engine)
[db.dbName/]_[tab.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/].to_parquet('[if (aWorkflow.environment.path.startsWith('.'))][aWorkflow.environment.path.replaceFirst('./', '/')/][else][aWorkflow.environment.path/][/if]/data/[if (tab.dataDictionary.fileName.trim().indexOf('.')>0)][tab.dataDictionary.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][tab.dataDictionary.fileName.trim()/].parquet[/if]')

				[/for]																										[comment CLOSE traverse the tables in the database/]
			[elseif (db.type=DBTYPE::SQLSERVER)]																			[comment OPEN checks if the Database is SQLServer/]
				[if (db.auth.oclIsKindOf(Credentials))]																		[comment OPEN checks if the autentication uses credentials/]
					[let cr : Credentials = db.auth.oclAsType(Credentials)]													[comment OPEN assigns the variable to be Credentials/]
engine = create_engine('mssql+pyodbc://[cr.username/]:[cr.passwd/]@[db.host/]/[db.dbName/]?driver=ODBC+Driver+17+for+SQL+Server')
					[/let]																									[comment CLOSE assigns the variable to be Credentials/]
				[elseif (db.auth.oclIsKindOf(OAuth2))]																		[comment OPEN checks if the autentication uses OAuth2/]
					[let oa : OAuth2 = db.auth.oclAsType(OAuth2)]															[comment OPEN assigns the variable to be OAuth2/]
					[/let]																									[comment CLOSE assigns the variable to be OAuth2/]
				[elseif (db.auth.oclIsKindOf(SSL))]																			[comment OPEN checks if the autentication uses SSL/]
					[let ssl : SSL = db.auth.oclAsType(SSL)]																[comment OPEN assigns the variable to be SSL/]
					[/let]																									[comment CLOSE assigns the variable to be SSL/]
				[/if]																										[comment CLOSE checks the autentication type/]
				[for (tab : Table | db.table)]																				[comment OPEN traverse the tables in the database/]
[db.dbName/]_[tab.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/] = pd.read_sql('SELECT * FROM [tab.dataDictionary.fileName.trim().replaceAll('\\.(.*?)(\\s|$)|.*/', '')/];', engine)
[db.dbName/]_[tab.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/].to_parquet('[if (aWorkflow.environment.path.startsWith('.'))][aWorkflow.environment.path.replaceFirst('./', '/')/][else][aWorkflow.environment.path/][/if]/data/[if (tab.dataDictionary.fileName.trim().indexOf('.')>0)][tab.dataDictionary.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][tab.dataDictionary.fileName.trim()/].parquet[/if]')

				[/for]																										[comment CLOSE traverse the tables in the database/]
			[elseif (db.type=DBTYPE::ORACLE)]																				[comment OPEN checks if the Database is Oracle/]
				[if (db.auth.oclIsKindOf(Credentials))]																		[comment OPEN checks if the autentication uses credentials/]
					[let cr : Credentials = db.auth.oclAsType(Credentials)]													[comment OPEN assigns the variable to be Credentials/]
engine = create_engine('oracle+oracledb://[cr.username/]:[cr.passwd/]@[db.host/]:[db.port/]/?service_name=[db.dbName/]')
					[/let]																									[comment CLOSE assigns the variable to be Credentials/]
				[elseif (db.auth.oclIsKindOf(OAuth2))]																		[comment OPEN checks if the autentication uses OAuth2/]
					[let oa : OAuth2 = db.auth.oclAsType(OAuth2)]															[comment OPEN assigns the variable to be OAuth2/]
					[/let]																									[comment CLOSE assigns the variable to be OAuth2/]
				[elseif (db.auth.oclIsKindOf(SSL))]																			[comment OPEN checks if the autentication uses SSL/]
					[let ssl : SSL = db.auth.oclAsType(SSL)]																[comment OPEN assigns the variable to be SSL/]
					[/let]																									[comment CLOSE assigns the variable to be SSL/]
				[/if]																										[comment CLOSE checks the autentication type/]
				[for (tab : Table | db.table)]																				[comment OPEN traverse the tables in the database/]
[db.dbName/]_[tab.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/] = pd.read_sql('SELECT * FROM [tab.dataDictionary.fileName.trim().replaceAll('\\.(.*?)(\\s|$)|.*/', '')/]', engine)
[db.dbName/]_[tab.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/].to_parquet('[if (aWorkflow.environment.path.startsWith('.'))][aWorkflow.environment.path.replaceFirst('./', '/')/][else][aWorkflow.environment.path/][/if]/data/[if (tab.dataDictionary.fileName.trim().indexOf('.')>0)][tab.dataDictionary.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][tab.dataDictionary.fileName.trim()/].parquet[/if]')

				[/for]																										[comment CLOSE traverse the tables in the database/]
			[elseif (db.type=DBTYPE::MONGODB)]																				[comment OPEN checks if the Database is Mongodb/]
				[if (not db.auth->isEmpty())]																				[comment OPEN checks if the autentication is not empty/]
					[if (db.auth.oclIsKindOf(Credentials))]																	[comment OPEN checks if the autentication uses credentials/]
						[let cr : Credentials = db.auth.oclAsType(Credentials)]												[comment OPEN assigns the variable to be Credentials/]
client = pymongo.MongoClient("mongodb://[cr.username/]:[cr.passwd/]@[db.host/]:[db.port/]/")
						[/let]																								[comment CLOSE assigns the variable to be Credentials/]
					[elseif (db.auth.oclIsKindOf(OAuth2))]																	[comment OPEN checks if the autentication uses OAuth2/]
						[let oa : OAuth2 = db.auth.oclAsType(OAuth2)]														[comment OPEN assigns the variable to be OAuth2/]
						[/let]																								[comment CLOSE assigns the variable to be OAuth2/]
					[elseif (db.auth.oclIsKindOf(SSL))]																		[comment OPEN checks if the autentication uses SSL/]
						[let ssl : SSL = db.auth.oclAsType(SSL)]															[comment OPEN assigns the variable to be SSL/]
						[/let]																								[comment CLOSE assigns the variable to be SSL/]
					[/if]																									[comment CLOSE checks the autentication type/]
				[elseif (db.auth->isEmpty())]																				[comment OPEN checks if the autentication is empty/]
client = pymongo.MongoClient("mongodb://[db.host/]:[db.port/]/")
				[/if]																										[comment CLOSE checks if the autentication is empty or not/]
[db.dbName/]_db = client['['/]"[db.dbName/]"[']'/]
				[for (tab : Table | db.table)]																				[comment OPEN traverse the tables in the database/]
[tab.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/]_collection = [db.dbName/]_db['['/]"[tab.dataDictionary.fileName.trim().replaceAll('\\.(.*?)(\\s|$)|.*/', '')/]"[']'/]
[tab.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/]_data = [tab.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/]_collection.find()
[db.dbName/]_[tab.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/] = pd.DataFrame(json_normalize([tab.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/]_data))

if '_id' in [db.dbName/]_[tab.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/].columns:
    [db.dbName/]_[tab.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/]['['/]'_id'[']'/] = [db.dbName/]_[tab.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/]['['/]'_id'[']'/].astype(str)

[db.dbName/]_[tab.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/].to_parquet('[if (aWorkflow.environment.path.startsWith('.'))][aWorkflow.environment.path.replaceFirst('./', '/')/][else][aWorkflow.environment.path/][/if]/data/[if (tab.dataDictionary.fileName.trim().indexOf('.')>0)][tab.dataDictionary.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][tab.dataDictionary.fileName.trim()/].parquet[/if]')

				[/for]																										[comment CLOSE traverse the tables in the database/]
			[elseif (db.type=DBTYPE::DYNAMODB)]																				[comment OPEN checks if the Database is Dynamodb/]
				[if (not db.auth->isEmpty())]																				[comment OPEN checks if the autentication is not empty/]
					[if (db.auth.oclIsKindOf(AWS))]																			[comment OPEN checks if the autentication uses AWS credentials/]
						[let aws : AWS = db.auth.oclAsType(AWS)]															[comment OPEN assigns the variable to be AWS/]
dynamodb = boto3.resource(
    'dynamodb',
    region_name="[aws.region/]",
    aws_access_key_id='[aws.accessKey/]',
    aws_secret_access_key='[aws.secretId/]',
    endpoint_url="[aws.endpointURL/]"
)
						[/let]																								[comment CLOSE assigns the variable to be AWS/]
					[/if]																									[comment CLOSE checks if the autentication uses AWS credentials/]
				[/if]																										[comment CLOSE checks if the autentication is empty/]
				[for (tab : Table | db.table)]																				[comment OPEN traverse the tables in the database/]
[db.dbName/]_[tab.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/]_table = dynamodb.Table('[tab.dataDictionary.fileName.trim().replaceAll('\\.(.*?)(\\s|$)|.*/', '')/]')
[db.dbName/]_[tab.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/]_response = [db.dbName/]_[tab.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/]_table.scan()
[db.dbName/]_[tab.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/]_data = [db.dbName/]_[tab.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/]_response['['/]'Items'[']'/]
[db.dbName/]_[tab.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/] = pd.DataFrame(json_normalize([db.dbName/]_[tab.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/]_data))
[db.dbName/]_[tab.dataDictionary.name.replaceAll('[(),-/\\s]+', '_')/].to_parquet('[if (aWorkflow.environment.path.startsWith('.'))][aWorkflow.environment.path.replaceFirst('./', '/')/][else][aWorkflow.environment.path/][/if]/data/[if (tab.dataDictionary.fileName.trim().indexOf('.')>0)][tab.dataDictionary.fileName.trim().replaceAll('\\.(.*?)(\\s|$)', '.parquet')/][else][tab.dataDictionary.fileName.trim()/].parquet[/if]')

				[/for]																										[comment CLOSE traverse the tables in the database/]
			[/if]																											[comment CLOSE checks the type Database of the Database/]
		[/let]																												[comment CLOSE assigns the variable to be a Database/]
	[/if]																													[comment CLOSE checks if the storage is a LocalFolder or a Database/]
[/for]																														[comment CLOSE traverse the storages in the environment/]
[/file]																														[comment CLOSE creates the fileFormatting file/]
[/template]





